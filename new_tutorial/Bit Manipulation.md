# Bit Manipulation

## การเก็บข้อมูลจำนวนเต็มของคอมพิวเตอร์

หลายท่านอาจได้รู้มาแล้วก่อนหน้านี้ว่าจำนวนเต็มในหลายๆภาษานั้นเก็บไปในรูปแบบเลขฐานสอง โดยหลักขวาสุดคือหลักทมี่มีค่าน้อยสุด คือ $2^0$ และหลักซ้ายสุดคือหลักที่มีค่ามากสุด สำหรับ signed 32-bit integer หลักซ้ายสุดคือ $2^{31}$ และสำหรับ signed 64-bit integer หลักซ้ายสุดคือ $2^{63}$ อย่างไรก็ตามเราก็สามารถมองตัวเลขฐานสองได้อีกแบบว่าเป็น string ที่มีค่า 0 กับ 1 เท่านั้นเช่นกัน

## Bit operation พื้นฐาน

หลายๆภาษาเช่น C++ กับ Java มักมี operation สำหรับเลขฐานสองโดยเฉพาะที่เราสามารถใช้ได้ดังต่อไปนี้

| Operation   | วิธีการใช้               | การทำงาน                                                     |
| ----------- | --------------------- | :----------------------------------------------------------- |
| AND         | ```result = a & b```  | สำหรับทุกหลักที่เป็น 1 ใน a และ b พร้อมกัน หลักนั้นของ result จะเป็น 1 มิเช่นนั้น หลักนั้นของ result จะเป็น 0<br />ยกตัวอย่างเช่น a = 1101, b = 1011 $\to$ result = 1001 |
| OR          | ```result = a | b```  | สำหรับทุกหลักที่เป็น 1 ใน a หรือ b หลักนั้นของ result จะเป็น 1 มิเช่นนั้น ถ้าหากหลักนั้นเป็น 0 ใน a และ b พร้อมกัน หลักนั้นของ result จะเป็น 0<br />ยกตัวอย่างเช่น a = 1001, b = 0010 $\to$ result = 1011 |
| XOR         | ```result = a ^ b```  | สำหรับทุกหลักที่แตกต่างกันระหว่าง a และ b คือหลักนั้นเป็น 0 ใน a และ 1 ใน b หรือหลักนั้นเป็น 1 ใน a และ 0 ใน b หลักนั้นของ result จะเป็น 1 มิเช่นนั้นสำหรับทุกหลักที่เหมือนกันใน a และ b หลักนั้นจะเป็น 0 ใน result |
| NOT         | ```result = ~a```     | เปลี่ยนทุกหลักใน a ที่เป็น 0 ให้เป็น 1 และหลักที่เป็น 1 ให้เป็น 0           |
| Left shift  | ```result = a << b``` | เพิ่ม 0 ด้านหลังของ a จำนวน b ตัวและย้ายหลักที่มีอยู่ใน a ไปด้านซ้าย<br />ยกตัวอย่างเช่น a = 1011 $\to$ a << 2 = 101100 |
| Right shift | ```result = a >> b``` | เลื่อกทุกหลักของ a ไปด้านขวาจนกว่าหลักที่ b ในข้างต้นกลายเป็นหลักที่ 0 โดยที่เลขที่อยู่ในหลักน้อยกว่า b จะถูกตัดทิ้งไป<br />ยกตัวอย่างเช่น a = 1011 $\to$ a >> 2 = 10 |

## เลขยกกำลังสองโดยใช้ bit operation

แม้ว่า C++ และภาษาอื่นๆจะมี builtin function สำหรับการยกกำลังตัวเลขอยู่แล้ว แต่สำหรับเลขฐานสองนั้น การใช้ library เหล่านั้นมีประสิทธิภาพไม่มากเท่าการใช้ bit operation เนื่องจากคอมพิวเตอร์เก็บจำนวนเต็มเป็นเลขฐานสองที่เรียงหลักซ้ายไปขวาจามากสุดไปน้อยสุด ดังนั้น ```a << 1``` จึงเท่ากับการนำ ```a``` ไปคูณสองและ ```a >> 1``` เท่ากับการนำ ```a``` ไปหารสองโดยปัดเศษลง ถ้าหากต้องการที่จะหา $2^n$ เราก็สามารถทำได้โดยใช้ ```1 << n``` เพียงเท่านั้น โดยไม่จำเป็นต้องใช้ library ที่ใช้อัลกอริทึมที่ซับซ้อนกว่าและมีประสิทธิภาพน้อยกว่า

## การหา $\log_2{n}$ โดยใช้ builtin function ของ GCC

ใน library ของ compiler GCC สำหรับภาษา C++ มี function ```__builtin_clz(x)``` ที่ใช้เอาไว้หาจำนวน leading zero ใน ```x``` คือจำนวน bit ทางซ้ายของ 1 ตัวแรก เราสามารถสังเกตุได้ว่า $\log_2{n}$ เท่ากับ ```31 - __builtin_clz(n)``` สำหรับเลข 32-bit และ ```63 - __builtin_clz(n)``` สำหรับเลข 64-bit

## การเปลี่ยน integer เป็น bit string เพื่อแสดงบนหน้าจอ

```c++
string int_to_bit_string(int x) {
  string s = "";
  while(x) {
    s += '0' + (x & 1); // นำบิตที่อยู่ทางด้านขวาสุดไปใส่ใน s โดยเปลี่ยนเป็น char ก่อน
    x >>= 1; // เลื่อนไปหาบิตต่อไป
  }
  reverse(s.begin(), s.end()); // ต้อง reverse เนื่องจากบิตน้อยสุดอยู่ด้านซ้ายสุด
  return s;
}
```

## การแทน subset ด้วยตัวเลขฐานสอง

ในกรณีที่จำนวนของในเซ็ตไม่เกิน 32 หรือว่า 64 เรามาสามารถที่จะใช้ตัวเลขฐานสองเพื่อแทน state ว่าของตัวใหนถูกเลือกบ้าง เช่นถ้าหากตัวเลขคือ 10110 set ของสิ่งของที่ถูกเลือกคือตัวที่ 1, 2, และ 4 (เนื่องจากเริ่มนับจาก 0) เหตุผลหลักของการใช้ตัวเลขฐานสองเพื่อแทนสถานะเพราะว่าหลาย operation ที่ทำบนเซ็ตนั้นสามารถทำได้โดยการใช้ bit operation ที่มีประสิทธิภาพมาก

หนึ่งใน operation ที่เรามักต้องการทำคือนำสองเซ็ตมา intersect กัน นั่นคือการสร้างเซ็ตใหม่ที่มีองค์ประกอบที่มีอยู่แล้วในทั้งสองเซ็ตในข้างต้น เช่นถ้าหากมีเซ็ต $A = \{1, 3, 5\}$ และ $B = \{1, 3, 4\}$ เซ็ตที่ได้จากการ intersect $A \cap B = \{1, 3\}$ ทั้งนี้ เราสามารถเขียนทั้ง A และ B ในรูปแบบเลขฐานสองแล้วถ้าหากนำ A & B จะได้เซ็ตที่ได้จากการ intersect ในรูปแบบเลขฐานสองเช่นกัน ในที่นี้ A = 101010 และ  B = 011010 จึงได้ A & B = 001010 ซึ่งคือเซ็ต $A \cap B = \{1, 3\}$ ในรูปแบบเลขฐานสองนั่นเอง

ในทางคล้ายๆกัน การนำสองเซ็ต A และ B มา union กัน นั่นคือการสร้างเซ็ตใหม่ที่มีองค์ประกอบที่มีอยู่แล้วในอย่างน้อยหนึ่งเซ็ตในข้างต้น ทำได้ด้วยการนำรูปแบบฐานสองของเซ็ต A และ B มา or กัน นั่นคือ A | B เช่นถ้าเรามี $A = \{1, 3, 5\}$ และ $B = \{1, 3, 4\}$ เช่นเดิม union ของทั้งสองเซ็ตคือ $A \cup B = \{1, 3, 4, 5\}$ และ A | B = 111010

เราสามารถบังคับให้เลือกหรือไม่เลือกบางองค์ประกอบของเซ็ตก็ได้ เช่นถ้าหากที A = 10110 และไม่อยากได้ของในหลักที่ 2 เราก็สามารถที่จะนำออกโดยการทำ ```A - (1 << 2)``` หรือถ้าหากต้องการจำเพิ่มของในหลักที่ 1 ก็สามารถทำได้โดยการทำ  ```A | (1 << 1)```