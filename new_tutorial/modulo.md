# คุณสมบัติเกี่ยวกับ modulo ที่ควรรู้

ในโจทย์การนับ (พวก combinatorics, dynamic programming ฯลฯ) เราอาจจะต้องคำนวณตัวเลขซึ่งมีขนาดใหญ่มากเกินกว่าที่ int หรือ long long จะรับไหว ดังนั้นโจทย์ส่วนใหญ่จะให้เราปรินท์คำตอบใน modulo อะไรสักอย่าง (ที่พบบ่อย ๆ คือ 1e9+7) เนื่องจากว่า modulo มีคุณสมบัติที่ทำให้เราสามารถคิดคำตอบได้โดยไม่จำเป็นต้องคำนวณเกิน int หรือ long long เลย

### ความหมายของ binary operator "mod"

กำหนดให้ a และ b เป็นจำนวนเต็มบวก a mod b จะมีค่าเท่ากับเศษที่ได้จากการหาร a ด้วย b เช่น

-   10 mod 3 = 1 เพราะ 10 หารด้วย 3 ได้ 3 เศษ 1 (10 = 3\*3+1)
-   27 mod 4 = 3 เพราะ 27 หารด้วย 4 ได้ 6 เศษ 3 (27 = 4\*6+3)

ในภาษา C หรือ C++ จะใช้สัญลักษณ์ % แทนการ mod (เช่น 10 mod 3 ก็คือ 10 % 3)

กรณีที่ a เป็นจำนวนเต็มลบ

หากคิดตามนิยามของ mod แล้ว เศษควรมีค่าอยู่ตั้งแต่ 0 ถึง |b|-1 เสมอ ดังนั้น ให้พิจารณาจากสูตร a = b(ผลหาร) + (เศษการหาร) โดยพยายามปรับให้เศษการหารอยู่ในช่วงเสมอ

-   -10 mod 3 หากเราคิดว่า (-10) = 3(-3) + (-1) จะทำให้เศษการหารอยู่นอกเหนือจากช่วงที่กำหนด ต้องคิดว่า (-10) = 3(-4) + (2) แทน ดังนั้น -10 mod 3 = 2
-   -15 mod 4 หากเราคิดว่า (-15) = 4(-3) + (-3) จะทำให้เศษการหารอยู่นอกเหนือจากช่วงที่กำหนด ต้องคิดว่า (-15) = 4(-4) + (1) แทน ดังนั้น -15 mod 4 = 1

(กรณีที่ b เป็นจำนวนเต็มลบสามารถคิดได้คล้าย ๆ กัน แต่ขอไม่กล่าวถึงเนื่องจากเป็นกรณีที่ไม่ค่อยเจอในการทำโจทย์ต่าง ๆ)

หากเราคิดเช่นนี้ ก็จะสังเกตได้ว่าตัวเลขจะวนไปเรื่อย ๆ ตั้งแต่ 0 ถึง |b|-1 เช่น ..., -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, ... ใน modulo 4 ก็จะมีค่าเท่ากับ 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, ... (ลองคิดภาพเป็นนาฬิกาก็ได้)

อนึ่ง สัญลักษณ์ % ในภาษา C/C++ จะไม่ได้คิด mod ตามวิธีที่ถูกต้อง ดังนั้น เราต้องบวก mod เพื่อแก้ปัญหา เช่น

-   -10 % 3 = -1 ดังนั้น -10 mod 3 ควรมีค่าเท่ากับ (-1)+3 = 2 ตามที่คิดไว้ข้างต้น
-   -15 % 4 = -3 ดังนั้น -15 mod 4 จะมีค่าเท่ากับ (-3)+4 = 1 ตามที่คิดไว้ข้างต้น

### คุณสมบัติที่เกี่ยวข้องกับ modulo

สมบัติการบวก: (a+b) mod n = ((a mod n) + (b mod n)) mod n

หากเราต้องการหาผลบวกของจำนวนเต็มหลาย ๆ ตัวใน modulo n เราไม่จำเป็นต้องบวกให้เสร็จก่อนแล้วค่อย mod ก็ได้ แต่เราสามารถ mod ไปเรื่อย ๆ ขณะที่บวกเลขได้เลย เช่น หากต้องการทราบค่าของ (4+2+5+5) mod 6 เราสามารถคิดตามขั้นตอนได้ดังนี้

-   (4+2) mod 6 = 6 mod 6 = 0
-   (0+5) mod 6 = 5 mod 6 = 5
-   (5+5) mod 6 = 10 mod 6 = 4

ดังนั้น (4+2+5+5) mod 6 = 4

สังเกตว่าการที่เราสามารถบวกแล้ว mod ทุกขั้น ทำให้เราไม่จำเป็นต้องใช้ตัวแปรที่มีขนาดใหญ่เกินกว่า int หรือ long long เลย (เช่น หาก mod 1e9+7 ใช้เพียงแค่ int ก็พอ)

สมบัติการลบ: (a-b) mod n = ((a mod n) - (b mod n)) mod n (นิยามให้ a-b = a+(-b))

สามารถใช้ได้เหมือนการบวก แต่เวลาลบแล้ว mod แล้ว ต้องระวังเลขติดลบเหมือนกรณีข้างบน เช่น (3-5)%3 = (-2)%3 = -2 ดังนั้น หากต้องการคิด (3-5) mod 3 ต้องนำ (-2)+3 = 1

สมบัติการคูณ: (a*b) mod n = ((a mod n) * (b mod n)) mod n

เช่นเดียวกับการบวก เราสามารถคูณไปด้วย mod ไปด้วยเลยได้เช่นกัน แต่มีข้อพึงระวังอย่างหนึ่ง หาก n มีค่าเท่ากับ 1e9+7 แล้วเราใช้ตัวแปร a กับ b เป็น int เวลาคิด a*b อาจจะ overflow ได้ (เพราะถ้า a = b = 1e9 จะได้ a*b = 1e18 เลยทีเดียว)

```cpp
int product = ( (long long)a \* b ) % n
```

หรือเขียนอีกแบบสั้น ๆ ได้ก็คือ

```cpp
int product = (a*1LL*b) % n;
```

Credits: aquablitz11