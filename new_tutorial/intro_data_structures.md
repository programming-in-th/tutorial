# Data Structures

Data Structure หรือโครงสร้างข้อมูล เป็นวิธีการเก็บข้อมูลในรูปแบบหนึ่งเพื่อให้ทำอะไรบางอย่างได้รวดเร็วขึ้น เช่น การเก็บข้อมูลตัวเลขให้เรียงจากน้อยไปมากตลอด โดยสามารถเพิ่ม/ลบ/ค้นหาตัวเลขใด ๆ ได้ในเวลา `O(log n)` เป็นต้น

ในการแข่งขัน TOI ส่วนใหญ่แล้ว เราไม่จำเป็นต้อง implement Data Structure เอง แต่สามารถใช้ Standard Template Library (STL) ของภาษา C++ เข้ามาช่วยได้ เพราะฉะนั้น ในหัวข้อนี้เราจะกล่าวถึงรูปแบบของการเก็บข้อมูลคร่าว ๆ เพื่อให้ทราบว่าสามารถใช้ทำอะไรได้บ้างเท่านั้น จะไม่ลงรายละเอียด หากต้องการศึกษาข้อมูลเพิ่มเติม สามารถหาได้จากอินเทอร์เน็ต

ทั้งนี้ สำหรับ Data Structure ประเภท Union-find Disjoint Set จะกล่าวถึงโดยละเอียด เนื่องจากจะต้อง implement Data Structure ดังกล่าวด้วยตนเอง

## Array และ Vector

### Array ใน C/C++

array เป็นรูปแบบการเก็บข้อมูลโดยเก็บข้อมูลเรียงเป็นตำแหน่งติด ๆ กันในหน่วยความจำ ทำให้สามารถเข้าถึงสมาชิก ณ ตำแหน่งใด ๆ ได้ในเวลา `O(1)` สำหรับการ implement เชื่อว่าน่าจะรู้กันดีอยู่แล้วว่าใช้ยังไง ดังนั้นขอกล่าวถึงเทคนิคที่แนะนำให้ใช้ในการทำโจทย์หลาย ๆ ข้อเท่านั้น ดังนี้

**1-based index**

โจทย์บางข้ออาจต้องการให้ใช้ index เป็นเลข `1` ถึง `n` แต่ตามปกติแล้ว array ขนาด `n` จะรองรับได้แค่เลข `0` ถึง `n-1` เท่านั้น มีวิธีแก้ปัญหาสองแบบคือ
- เมื่อ input ต้องการให้จัดการกับข้อมูล ณ ตำแหน่ง `x` ก็ให้เลื่อนมาจัดการกับตำแหน่ง `x-1` ใน array จริง ๆ แทน
- กำหนดขนาดของ array เป็น `n+1` เพื่อที่จะได้ใช้ตำแหน่ง `n` ได้ ส่วนตำแหน่ง `0` เราจะไม่พิจารณาเลย

**Global Constant-sized Array**

แทนที่จะประกาศ array ไว้ในฟังก์ชัน `main` แล้วส่งเป็น argument เมื่อจะเรียกฟังก์ชัน ควรประกาศ array ทุกอย่างไว้ใน global scope เลยเพื่อที่จะเข้าถึงได้ง่าย นอกจากนี้การประกาศใน global scope จะทำให้ค่าของ array ทุกช่องเป็น 0 โดยอัตโนมัติอีกด้วย (หากเป็น `char` ก็จะได้ `\0`, `bool` จะได้ `false` เป็นต้น)

สำหรับขนาดของ array ควรประกาศไว้เป็นค่าคงที่ โดยประกาศเป็นขนาดที่มากพอที่จะรองรับ input ของโจทย์ได้ อาจจะประกาศเผื่อไว้ด้วยเพื่อป้องกันความผิดพลาด เช่น หากโจทย์มี input ที่ `n <= 100000` ควรประกาศ array ขนาด 100,010 เป็นต้น

### Dynamic Array

Dynamic array โดยนิยามแล้วคือ array ที่สามารถขยายขนาดได้ ใน STL ของ C++ เราสามารถใช้ dynamic array ได้โดยการใช้ vector ซึ่ง API documentation สามารถหาได้ที่ [เว็บนี้](http://www.cplusplus.com/reference/vector/vector/)

ฟังก์ชันที่มี เช่น `push_back`, `pop_back`, `insert`, `erase`, `size` เป็นต้น สำหรับรายละเอียดการใช้งานให้อ่านใน reference ด้วยตนเอง

**ทำไมถึงต้องใช้ dynamic array?**

ปัญหาหลักของการใช้ array ธรรมดาคือการที่ขนาดของ array ไม่สามารถเปลี่ยนแปลงได้ ทั้งนี้มีหลายปัญหาที่ต้องการใช้ array ที่เปลี่ยนขนาดได้ เช่นถ้าหากเราต้องการที่จะเก็บข้อมูลเกี่ยวกับกองหนังสือกองหนึ่งที่ผู้ใช้สามารถใส่ทับหรือหยิบออกจากด้านบนได้โดยที่เราไม่รู้ว่าจำนวนหนังสือในกองมากที่สุดที่เป็นไปได้คือเท่าใด เราก็ไม่สามารถใช้ array ธรรมดาได้ เนื่องจากจำนวนหนังสือในกองอาจเกินความยาวของ array ฉนั้นเราต้องใช้ dynamic array มาช่วย

**วิธีการจัดสรรหน่วยความจำของ dynamic array**

เนื่องจาก array ธรรมดาไม่สามารถขยายความยาวได้ ดังนั้นเมื่อเราเติมข้อมูลถึงจุดที่ความยาวใกล้จะเกินแล้ว เราก็สามารถสร้าง array ใหม่ที่มีความยาวสองเท่าของ array เดิม แล้วก็ย้ายข้อมูลจาก array เดิมเข้าไปใน array ตัวใหม่ ถ้าหากตอนแรกเรามี array `A[4] = {1, 2, 3, 4}` และต้องการที่จะเพิ่ม `5` เข้าไปใน `A` เราก็จะสร้าง array `B = {1, 2, 3, 4, null, null, null, null}` และเปลี่ยน `B[5] = 5` จึงได้ `B = {1, 2, 3, 4, 5, null, null, null}`

เราสามารถเขียนอัลกอริทึมของการใส่ข้อมูลใหม่นี้ในรูปแบบทั่วไปได้ดังนี้

1. ให้ array `A` ขนาด `n` มา
2. ถ้าหากจำนวนของใน `A` ยังน้อยกว่าขนาดของ `A` ให้ใส่ในช่องว่างช่องแรก
3. มิเช่นนั้นให้สร้้าง array `B` ขึ้นมาที่มีขนาดเท่ากับ `2n`
4. ย้ายข้อมูลจาก `A` ไป `B` ทั้งหมด
5. ใส่ข้อมูลใหม่ในช่องว่างช่องแรกของ `B` 

ทั้งนี้คือวิธีการที่ dynamic array จัดสรรหน่วยความจำของ dynamic array ภายใน แต่ในการใช้จริง เรามันจะใช้ API ของ STL โดยตรง

**เวลาการทำงานของ dynamic array**

แม้่ว่าอัลกอริทึมในการ resize array อาจจะดูเหมือนไม่มีประสิทธิภาพ แต่อย่างไรก็ตามเราสามารถพิสูจน์ได้ว่าโดยรวมแล้วการ resize จะใช้เวลาการทำงานเท่ากับ $O(1)$ ต่อหน่วยข้อมูล หรือกล่าวในอีกนัยนึงคือ amortized compleixty ของอัลกอริทึมคือ $O(1)$

นิยาม $n$ เท่ากับความยาว array หลังการ resize ทั้งหมด และ $m$ เท่ากับจำนวนครั้งที่เกิดการ resize เราจะสามารถเห็นได้ว่า $m$ จะเป็น $O(\log_{2}{n})$ เนื่องจากเราจะ resize เป็นสองเท่าของความยาวเดิมเสมอ ฉนั้นในแต่ละขั้นตอน ขนาดของ array จะเท่ากับ $2^i$ โดยที่ $0 \leq i < m$

ฉนั้นการทำงานทั้งหมดจะใช้เวลาเท่ากับ
$$
\begin{align*}
T(n) &= O(2^0 + 2^1 + 2^2 + \dots + 2^{m-1}) \\
&= O(\frac{2^m - 1}{2 - 1}) \\
&= O(2^{\log_{2}{n} - 1}) \\
&= O(n)
\end{align*}
$$
ฉนั้นการทำงานต่อหนึ่งหน่วยข้อมูลเท่ากับ $O(1)$

## Linked List

ในขณะที่ array เก็บข้อมูลในตำแหน่งติด ๆ กัน linked list จะใช้วิธีเก็บข้อมูลแยกกัน โดยข้อมูลตัวที่ `i` จะมี pointer ชี้ไปยังตัวที่ `i+1` ดังนั้น หากเก็บตำแหน่งของข้อมูลตัวแรก ก็สามารถค้นหาข้อมูลทั้งหมดใน linked list ได้

สังเกตว่าเราจะไม่สามารถหาข้อมูล ณ ตำแหน่ง `x` ใด ๆ ได้ในเวลา `O(1)` เพราะเราไม่ทราบตำแหน่งที่แท้จริง ต้องเดินทางจากตำแหน่งแรกเป็นต้นไปเท่านั้น ดังนั้นการค้นหาใน Linked List อาจใช้เวลาได้มากถึง `O(n)` ส่วนการแทรก/ลบ หากทราบตำแหน่งที่ต้องการจะดำเนินการอยู่แล้ว จะทำการแทรก/ลบได้ในเวลา `O(1)` เพราะสิ่งที่ต้องทำมีเพียงแค่การจัดการปรับตัวชี้ตำแหน่งถัดไปเท่านั้น (เช่น ลำดับ `1, 3` หากจะแทรก `2` เข้าไป ก็แค่ต้องปรับให้ `1` เปลี่ยนมาชี้เลข `2` และ `2` ชี้เลข `3`)

หากเก็บเพียงแค่ตัวชี้ไปยังข้อมูลตัวถัดไป จะเรียกเป็น Singly Linked List แต่หากเก็บตัวชี้ไปยังข้อมูลก่อนหน้าด้วย จะเรียกว่า Doubly Linked List - หากเก็บทั้งไปและกลับ จะทำให้สามารถเดินทางใน linked list จากหน้าไปหลังหรือหลังไปหน้าก็ได้

วิธีการ implement สามารถหาตามอินเทอร์เน็ตทั่วไปได้ค่อนข้างง่าย ส่วน STL จะขอไม่กล่าวถึง เพราะโจทย์ TOI ส่วนใหญ่ ไม่มีความจำเป็นจะต้องใช้ linked list อยู่แล้ว

## Set และ Associative Array

### Set Abstract Data Type

คำว่า Set ในที่นี้เราจะยังไม่กล่าวถึงวิธีการดำเนินการ แต่จะสนใจเฉพาะสิ่งที่ทำได้เท่านั้น ดังนั้นจะถือว่า Set ในที่นี้เป็น Abstract Data Type (ADT) - สามารถจัดเก็บข้อมูลได้ โดยรองรับ operation ได้ดังนี้

- `find(x)` สามารถค้นหาได้ว่ามีข้อมูล `x` ในโครงสร้างข้อมูล
- `insert(x)` เพิ่มข้อมูล `x` ลงในโครงสร้างข้อมูล
- `erase(x)` ลบข้อมูล `x` ออกจากโครงสร้างข้อมูล

สังเกตว่าเราสามารถใช้ array/vector ปกติในการ implement ได้ แต่จะต้องจัดเรียง/แทรก/ลบข้อมูลตลอด ทำให้เวลาในการทำงานเป็น `O(n)` สำหรับแต่ละ operation ซึ่งถือว่าช้าเกินไป โดยปกติแล้วเราจะ implement Set ADT โดยใช้ Binary Search Tree ซึ่งจะทำให้แต่ละ operation ทำงานในเวลา `O(log n)`

### Binary Search Tree

Binary Search Tree (BST) เป็นหนึ่งในวิธีการเก็บข้อมูลตามนิยามของ Set ADT นั่นคือสามารถค้นหา/เพิ่ม/ลบข้อมูลได้ โดยเฉลี่ยแล้วใช้เวลา `O(log n)` ต่อครั้ง มีวิธีการจัดการดังนี้

เราจะเก็บข้อมูลแต่ละตัวใน 1 node แต่ละ node จะมีข้อมูลตัวเลขนั้น และมี pointer ชี้ไปยัง node ลูกซ้ายและลูกขวา (left child และ right child) โดยเราต้องการให้ node ทุก node ที่อยู่ทางซ้ายมีค่าน้อยกว่า node นี้ ส่วน node ที่อยู่ทางขวาทุกมีค่ามากกว่า node นี้

หากลำดับที่ได้เป็น `1, 3, 4, 6, 7, 8, 10, 13, 14` รูปแบบ BST แบบหนึ่งที่เป็นไปได้อาจเป็นดังนี้

![](https://raw.githubusercontent.com/aquablitz11/toi14-tutorial/master/images/bst.png)

จากคุณสมบัติการเรียงข้อมูล เราสามารถตอบได้ว่ามีค่า `x` ใน BST หรือไม่ โดยเดินทางจาก root node (node บนสุด) ลงไปเรื่อย ๆ จนกว่าจะเจอ หาก `x` มีค่าน้อยกว่า root node เราจะต้องเดินทางไปทางซ้าย เพราะคำตอบจะไม่อยู่ทางขวาแน่นอน (อย่าลืมว่าทางขวาจะมีค่ามากกว่า root node เสมอ) แต่หาก `x` มีค่ามากกว่า root node ก็จะเดินทางไปทางขวา เป็นต้น

สำหรับการเพิ่มและลบข้อมูลสามารถทำได้โดยการหาตำแหน่งแล้วจัดการสร้าง node/ลบ node/ปรับ pointer ตามความเหมาะสม สำหรับรายละเอียดสามารถหาอ่านได้ในอินเทอร์เน็ต

อนึ่ง เวลาในการทำงานจะเป็น `O(log n)` ก็ต่อเมื่อ BST นั้น balanced นั่นคือ leaf node (node ปลายล่างสุด) ส่วนใหญ่อยู่ลึกลงไปในระดับเดียวกัน หากความลึกของต้นไม้อยู่ที่ประมาณ `O(log n)` แล้ว operation ต่าง ๆ ก็จะทำงานใน `O(log n)` ด้วย (เพราะเราจะต้องเดินทางลงไปตามจำนวนชั้น)

การสร้าง Balanced BST (BBST) นั้นสามารถทำได้โดยปรับรูปแบบการเก็บข้อมูลตลอดที่มีการเปลี่ยนแปลงข้อมูล โดย BBST มีหลายแบบ เช่น AVL Tree, Red-Black Tree เป็นต้น ส่วนใหญ่แล้ว BBST มีความยุ่งยากในการ implement สูงมาก ไม่เหมาะกับการแข่งขัน ดังนั้นปกติแล้วเราจะใช้ `set` ใน STL แทน (STL จัดการ implement ส่วนพวกนี้ไว้ให้หมดแล้ว)

### Hash Table

Hash Table เป็นอีกวิธีในการ implement Set ADT กล่าวคือ implement data structure ที่สามารถรองรับ operation `find`, `insert` และ `delete` ได้ แต่ Hash Table จะต่างจาก BST ตรงที่ไม่มีการเรียงข้อมูลจากมากไปน้อย

หลักการทำงานของ Hash Table จะเป็นดังนี้
- กำหนด array ขึ้นมา ขนาดพอเหมาะ สมมุติว่าใช้ขนาด `n`
- กำหนด hash function `H(x)` ขึ้นมา โดยสำหรับข้อมูล `x` ใด ๆ จะต้องหาค่า `H(x)` ได้เป็นคำตอบในช่วง `0` ถึง `n-1`
- หากต้องการจะเพิ่มข้อมูล `x` เข้าใน hash table ให้นำไปจดไว้ที่ตำแหน่ง `H(x)` เลย (ถ้าเป็น array ปกติเราอาจจะจดเรียงตั้งแต่ตำแหน่ง 0 ถึง `n-1` ไป แต่ hash table จะใช้ค่า `H(x)` เป็นตัวกำหนดตำแหน่ง)
- หากต้องการจะลบข้อมูล `x` ก็ให้ไปลบที่ตำแหน่ง `H(x)`
- หากต้องการจะหาข้อมูล `x` ว่ามีหรือไม่ ให้ตรวจสอบที่ตำแหน่ง `H(x)` ว่ามีหรือไม่

สังเกตว่า hash function ของเราอาจจะทำให้ต้องนำข้อมูลไปใส่ไว้ในตำแหน่งเดียวกัน (เรียกว่า Hash Collision) ดังนั้น แทนที่แต่ละช่องของ array จะเก็บแค่จำนวนเดียว เราอาจจะแก้ปัญหาโดยใช้ `vector` แทนได้

ถ้าเราเลือก hash function ดีพอ ข้อมูลจะกระจายทั่วครบ `n` ช่องเป็นจำนวนเท่า ๆ กัน หากแต่ละช่องไม่มีข้อมูลซ้ำ หรือมีข้อมูลซ้ำน้อยมาก (เป็นค่าคงที่) เราอาจจะถือได้ว่า hash table รองรับ ทั้ง 3 operation ได้ในเวลา `O(1)`

ในที่นี้ขอไม่กล่าวถึงรายละเอียดการ implement เพราะ `unordered_set` ของ STL ได้ implement Hash Table ไว้อยู่แล้ว

### STL `set` และ `unordered_set`

สังเกตว่าข้อแตกต่างของ `set` และ `unordered_set` มีเพียงสองอย่างคือ
- `set` จะเก็บข้อมูลแล้วจัดเรียงตลอด ในขณะที่ `unordered_set` ไม่ได้เรียงข้อมูล แต่เก็บตามตำแหน่งของค่า hash ที่ได้
- `set` จะทำงานใน `O(log n)` โดยเฉลี่ย แต่ `unordered_set` จะทำงานใน `O(1)` หาก hash function ที่ STL มีให้ ดีพอ

โดยทั่วไป `unordered_set` ไม่ได้ดีกว่า `set` มากนัก เนื่องจาก `set` มีการเรียงข้อมูลจากน้อยไปมาก หากจำเป็นต้องไล่ข้อมูลเรียงตามลำดับบ่อย ๆ แนะนำให้ใช้ `set` เป็นหลัก ทั้งนี้แล้วแต่ความถนัด และความเหมาะสมที่จะนำมาใช้กับโจทย์ด้วย

ฟังก์ชันของ `set` และ `ordered_set` ที่เป็นไปได้ เช่น `insert`, `erase`, `count`, `size` ทั้งนี้ให้ศึกษาเองใน reference

ตัวอย่างการใช้งาน ดังนี้
```cpp
set<int> S;
S.insert(3);
S.insert(1);
printf("Found number %d: %s\n", 1, S.count(1) ? "True" : "False");
S.erase(3);
printf("Found number %d: %s\n", 3, S.count(3) ? "True" : "False");
```

อนึ่ง `set` และ `unordered_set` จะไม่รองรับการเก็บข้อมูลซ้ำกัน (หากพยายาม insert ข้อมูลซ้ำ จะไม่มีอะไรเกิดขึ้น) หากต้องการเก็บข้อมูลซ้ำครบทุกตัว จะต้องใช้ `multiset` หรือ `unordered_multiset` แทน

### Associative Array ADT

Associative Array เป็น Abstract Data Type ที่รองรับ operation คล้ายคลึงกับ array มาก แต่แทนที่จะใช้ index `0` ถึง `n-1` Associative Array จะอนุญาตให้ใช้ index อะไรก็ได้ ตามชนิดที่กำหนดไว้ ยกตัวอย่าง Associative Array `A` ที่มี index เป็น `string` และเก็บค่า `int` เราอาจจะใช้คำสั่ง `A["test"] = 1` ได้ เป็นต้น

การ implement Associative Array สามารถทำได้โดยดัดแปลงการเก็บข้อมูลของ Binary Search Tree คือจะเก็บข้อมูลเป็นคู่อันดับ `(key, value)` (`key` คือ index) เมื่อต้องการจัดการกับข้อมูลในตำแหน่ง `key` ก็เพียงแค่หาตำแหน่ง `key` ใน Binary Search Tree แล้วจัดการกับค่า `value` ที่เก็บไว้คู่กัน เนื่องจากว่าใช้ BST ดังนั้น ข้อมูลใน BST จะเรียงตาม `key` ด้วย ใน STL ได้ implement เป็น `map` ไว้ให้ใช้แล้ว

นอกจากนี้ อาจจะใช้ Hash Table ในการ implement โดยเก็บเป็นคู่อันดับคล้าย ๆ กัน ใน STL ได้ implement เป็น `unordered_map` ไว้ให้ใช้แล้ว

### STL `map` และ `unordered_map`

`map` และ `unordered_map` จะทำงานคล้ายกับ `set` และ `unordered_set` มาก แต่การ `insert` หรือ `erase` จะใช้เป็นคู่อันดับ `(key, value)` แทน นอกจากนี้ การเข้าถึงข้อมูล ณ index `key` สามารถใช้ได้เหมือน array ทั่วไปเลย (ความจริงแล้วไม่ต้องใช้ `insert` เลยก็ได้ สามารถกำหนดค่าเหมือน array ได้เลย)

ตัวอย่างการใช้งาน ดังนี้

```cpp
map<string, double> nums;
nums["pi"] = 3.1415926;
nums["e"] = 2.7182818;
string s = "pi";
printf("%.6f\n", nums[s]);
```

`map` และ `unordered_map` จะไม่รองรับการเก็บข้อมูลที่มี `key` ซ้ำกัน ซึ่งถือว่าปกติ เพราะ array ปกติ ช่องหนึ่งก็เก็บได้ค่าเดียวอยู่แล้ว ถึงอย่างไรก็ตามหากต้องการเก็บ `key` ซ้ำ สามารถใช้ `multimap` หรือ `unordered_multimap` แทนได้ แต่จะเสียคุณสมบัติความเป็น associative array ไป (ไม่สามารถเข้าถึงสมาชิกโดยใช้ `[]` ได้อีกแล้ว)

ทั้งนี้ ให้ศึกษาข้อมูลฟังก์ชันอื่น ๆ เพิ่มเติมจาก reference

## Stack และ Queue

Stack และ Queue เป็น data structure ที่ไม่มีความซับซ้อนอะไรมาก รองรับ operation การเพิ่มข้อมูล หรือนำข้อมูลออกเท่านั้น โดยการเพิ่ม/นำข้อมูลออก จะมีลักษณะพิเศษ ดังนี้

### Stack (STL `stack`)

Stack จะมีลักษณะคล้าย ๆ กองจานวางเรียงกันอยู่ โดยเมื่อวางจานเพิ่ม จานจะอยู่ทางด้านบนสุด และเมื่อจะนำจานออก ก็จะต้องนำออกจากชั้นบนสุดเช่นกัน ลักษณะการเก็บข้อมูลดังกล่าวเรียกว่า Last-In First-Out (LIFO) นั่นคือข้อมูลที่เพิ่งใส่ไปเป็นตัวท้ายจะถูกดึงออกมาเป็นตัวแรก

เราอาจจะ implement Stack ได้โดยใช้ array ง่าย ๆ หรืออาจจะเป็น Linked List ก็ได้ สำหรับภาษา C++ วิธีที่ง่ายที่สุดคือการใช้ STL `stack` ซึ่งมี operation คือ `push` (เพิ่มข้อมูล), `top` (ดูข้อมูลตัวบนสุด) และ `pop` (นำข้อมูลตัวบนสุดออก) เพียงเท่านั้น

```cpp
stack<int> S;
S.push(1);
S.push(2);
printf("%d\n", S.top()); // got 2
S.pop();
printf("%d\n", S.top()); // got 1
S.pop();
```

ทั้งนี้ ให้ศึกษาข้อมูลฟังก์ชันอื่น ๆ เพิ่มเติมจาก reference

### Queue (STL `queue`)

ตามชื่อ ข้อมูลที่ถูกใส่เข้าไปก่อน จะถูกนำออกมาก่อนคล้ายคลึงกับการต่อคิว เรียกว่า FIFO (First-In First-Out) การ implement สามารถทำได้โดยใช้ array หรือ linked list ง่าย ๆ เช่นกัน แต่ถ้าสะดวกสุด แนะนำให้ใช้ STL `queue` ซึ่งรองรับ operation `push` (เพิ่มข้อมูล), `front` (ดูข้อมูลหน้าคิว), `pop` (นำข้อมูลหน้าคิวออก)

```cpp
queue<int> Q;
Q.push(1);
Q.push(2);
printf("%d\n", Q.top()); // got 1
Q.pop();
printf("%d\n", Q.top()); // got 2
Q.pop();
```

ทั้งนี้ ให้ศึกษาข้อมูลฟังก์ชันอื่น ๆ เพิ่มเติมจาก reference

### Double-ended Queue (STL `deque`)

นอกจากคิวที่เข้าทางท้ายคิวและออกทางหน้าคิวอย่างเดียวแล้ว ยังมีคิวแบบที่อนุญาตให้เพิ่ม/ออกทั้งทางด้านหน้าหรือด้านหลังอีกด้วย (ส่วนตัวตรงกลางจะไม่สามารถเอาออกได้ จนกว่าจะเอาตัวปลาย ๆ ออกก่อน)

ใน STL มี `deque` ให้ใช้ โดยรองรับ operation `push_front`, `push_back`, `front`, `back`, `pop_front`, `pop_back` (เหมือนกับ `queue` แต่มี `front`/`back` เพิ่มมาด้วย)

ทั้งนี้ ให้ศึกษาข้อมูลฟังก์ชันอื่น ๆ เพิ่มเติมจาก reference

## Priority Queue

Priority Queue เป็น Abstract Data Type ที่รองรับ operation 2 อย่างได้แก่
- `push(x)` นำข้อมูล `x` ใส่เข้าไปใน Priority Queue
- `pop()` นำข้อมูลตัวที่มี priority สูงสุดออกจาก Priority Queue

สังเกตว่า Priority Queue จะมีการจัดลำดับความสำคัญให้กับข้อมูล โดยข้อมูลที่สำคัญที่สุดจะถูกดึงออกมาก่อน เช่น หากเก็บจำนวนใน Min Priority Queue ข้อมูลที่มีค่าน้อยที่สุดจะถูกดึงออกมาก่อน เป็นต้น

โดยปกติแล้วจะ implement Priority Queue โดยใช้โครงสร้างข้อมูล Binary Heap ถึงอย่างไรก็ตาม ใน STL มี `priority_queue` เตรียมไว้ให้ใช้แล้ว สามารถใช้ได้เลย

ในที่นี้ ขอไม่กล่าวถึงรายละเอียดการทำงานของ Binary Heap

### STL `priority_queue`

`priority_queue` ของ STL ปกติจะทำงานโดยให้ความสำคัญกับตัวเลขที่มีค่ามากที่สุดก่อน นั่นคือทำงานเป็น Max Priority Queue ฟังก์ชันที่มีให้ใช้งานได้แก่ `push` (เพิ่มข้อมูลเข้าไป), `top` (ดูข้อมูลตัวที่มีค่ามากสุด), `pop` (นำข้อมูลตัวบนสุดออก)

หากต้องการใช้ Min Priority Queue เราอาจจะปรับวิธีการเปรียบเทียบข้อมูลได้ เช่น หากจะเก็บข้อมูลจำนวนเต็ม ตามปกติแล้ว Max Priority Queue จะใช้ `less<int>` ในการเปรียบเทียบ แต่หากต้องการใช้ Min Priority Queue เราจะต้องใช้ `greater<int>` ในการเปรียบเทียบ ดังตัวอย่างด้านล่าง

```cpp
priority_queue<int> maxheap;
maxheap.push(3);
maxheap.push(5);
maxheap.push(1);
printf("%d\n", maxheap.top()); // got 5
maxheap.pop();
printf("%d\n", maxheap.top()); // got 3
maxheap.pop();

priority_queue<int, vector<int>, greater<int>> minheap;
minheap.push(3);
minheap.push(5);
minheap.push(1);
printf("%d\n", minheap.top()); // got 1
minheap.pop();
printf("%d\n", minheap.top()); // got 3
minheap.pop();
```

ทั้งนี้ ให้ศึกษาข้อมูลฟังก์ชันอื่น ๆ เพิ่มเติมจาก reference

## Union-find Disjoint Set

Union-find Disjoint Set (DSU) เป็นโครงสร้างข้อมูลที่ใช้ในการเก็บข้อมูลการอยู่ร่วมกันเป็นกลุ่ม ๆ ของสิ่งของอะไรบางอย่าง โดยสิ่งของอย่างหนึ่งจะอยู่ได้ในกลุ่มเดียวเท่านั้น นอกจากนี้ อาจจะนำกลุ่มมารวมกันได้ตลอด ยกตัวอย่าง การจัด node ในกราฟเป็นกลุ่ม ๆ โดยให้ node ที่อยู่ใน component เดียวกันอยู่กลุ่มเดียวกัน และหากมีการเพิ่ม edge เปรียบเสมือนกันนำ 2 component นั้นมารวมกัน

สิ่งของในที่นี้ จะขอเรียกว่า node - DSU จะเก็บข้อมูลการอยู่ร่วมกันเป็นกลุ่ม โดยแต่ละกลุ่มจะมีตัวแทนกลุ่มอยู่ 1 node ส่วน node อื่น ๆ จะมี parent pointer ชี้ต่อกันไปเรื่อย ๆ จนไปถึงตัวแทนกลุ่ม (ส่วนตัวแทนกลุ่มชี้เข้าหาตนเอง)

เช่น หากกลุ่มหนึ่งมีสมาชิกเป็น `1, 2, 3, 4` โดยที่ `2` เป็นตัวแทนกลุ่ม จะได้ข้อมูล parent ดังนี้
- `parent[2] = 2` (2 เป็นตัวแทนกลุ่มเลยชี้เข้าหาตนเอง)
- `parent[1] = 2`
- `parent[3] = 2`
- `parent[4] = 3` (สังเกตว่า `4` ไม่ได้ชี้เข้าหา `2` โดยตรง แต่ชี้ที่ `3` แล้ว `3` ก็ชี้ต่อไปหา `2`)

เราจะกำหนดฟังก์ชัน `root(u)` เพื่อให้หาตัวแทนกลุ่มได้อย่างรวดเร็ว โดยเดินทางตาม `parent` ไปเรื่อย ๆ จนกว่าจะเจอ node ตัวแทน

```cpp
int root(int u) {
    if (parent[u] == u) // found
        return u;
    return root(parent[u]); // keep going
}
```

สังเกตว่าหากมีการชี้ต่อกันเป็นจำนวนมาก การค้นหาตัวแทนกลุ่มบ่อย ๆ จะใช้เวลานาน ดังนั้น เมื่อเจอตัวแทนกลุ่มของ node `u` แล้ว (สมมุติว่าเจอตัวแทนกลุ่มเป็น `r`) เราควรปรับให้ `parent[u] = r` เพื่อที่ครั้งหน้า เวลาเรียก `root(u)` จะได้หาตัวแทนกลุ่มได้ทันที เทคนิคนี้เรียกว่า Path Compression

```cpp
int root(int u) {
    if (parent[u] == u) // found
        return u;
    return parent[u] = root(parent[u]); // keep going
    // ^ notice parent[u] is set to the representative
}
```

ถ้าเราต้องการตรวจสอบว่า node `u` และ `v` อยู่กลุ่มเดียวกันหรือไม่ ก็สามารถตรวจสอบได้ง่าย ๆ โดยการหาตัวแทนกลุ่มทั้งคู่ หากตัวแทนกลุ่มเหมือนกัน ก็คืออยู่กลุ่มเดียวกัน

```cpp
bool is_same(int u, int v) {
    return root(u) == root(v);
}
```

หากเรามี node `u` และ `v` ซึ่งอยู่คนละกลุ่มกัน แล้วต้องการรวมสองกลุ่มเข้าด้วยกัน สามารถทำได้โดยให้ตัวแทนกลุ่มของ `u` ไปชี้ตัวแทนกลุ่มของ `v` (หรือจะสลับกันก็ได้)

```cpp
void merge(int u, int v) {
    u = root(u), v = root(v); // find representative first
    if (u == v) // already in same group
        return;
    parent[u] = v; // merging
}
```

เพียงแค่นี้้เราก็ได้ Union-find Disjoint Set แล้ว อนึ่ง อย่าลืมปรับ `parent[u] = u` ตอนเริ่มต้น เพราะว่าทุก node อยู่กลุ่มต่างกันหมด

อนึ่ง นอกจากเทคนิค Path Compression ที่ช่วยให้สามารถค้นหาตัวแทนกลุ่มได้อย่างรวดเร็วแล้ว ยังมีเทคนิค Union by Rank ซึ่งอาจจะช่วยลดเวลาการทำงานได้อีก (แต่ลดไม่มาก) โดยหลักการเป็นดังนี้
- นอกจาก `parent` แล้ว แต่ละ node จะต้องเก็บ `rnk` (rank) อีกด้วย
- สำหรับ node ที่ไม่ใช่ตัวแทนกลุ่ม เราจะไม่สนใจค่า `rnk`
- ถ้า node เป็นตัวแทนกลุ่ม ค่า `rnk` จะต้องเท่ากับจำนวน node ในกลุ่มทั้งหมด
- เมื่อนำตัวแทนกลุ่ม `u` และ `v` รวมเข้าด้วยกัน เราจะเลือกนำ node ที่มี `rnk` น้อย รวมเข้าสู่ node ที่มี `rnk` มากเสมอ (อย่าลืมปรับข้อมูล `rnk` ด้วย หลังรวมกลุ่มเสร็จ)

สังเกตว่าสิ่งที่ปรับเปลี่ยนมีเพียงแค่ array `rnk` ที่เพิ่มมา, ฟังก์ชัน `merge`, และการกำหนดให้ `rnk[u] = 1` สำหรับทุก node ตอนแรก (เพราะแต่ละ node อยู่กลุ่มที่มีแค่ตนเอง ก็คือมีสมาชิก 1 node)

```cpp
void merge(int u, int v) {
    u = root(u), v = root(v);
    if (u != v)
        continue;
    if (rnk[u] > rnk[v]) { // merge v into u
        rnk[u] += rnk[v];
        parent[v] = u;
    } else { // merge u into v
        rnk[v] += rnk[u];
        parent[u] = v;
    }
}
```

Data Structure นี้มีประโยชน์สำหรับ Kruskal's Algorithm ซึ่งมีไว้เพื่อหา Minimum Spanning Tree เป็นอย่างมาก ควรศึกษาสองอย่างนี้คู่กัน

Credits: [toi14-tutorial](https://github.com/aquablitz11/toi14-tutorial) by aquablitz11