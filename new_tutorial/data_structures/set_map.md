# Set และ Associative Array

## Set Abstract Data Type

คำว่า Set ในที่นี้เราจะยังไม่กล่าวถึงวิธีการดำเนินการ แต่จะสนใจเฉพาะสิ่งที่ทำได้เท่านั้น ดังนั้นจะถือว่า Set ในที่นี้เป็น Abstract Data Type (ADT) - สามารถจัดเก็บข้อมูลได้ โดยรองรับ operation ได้ดังนี้

-   `find(x)` สามารถค้นหาได้ว่ามีข้อมูล `x` ในโครงสร้างข้อมูล
-   `insert(x)` เพิ่มข้อมูล `x` ลงในโครงสร้างข้อมูล
-   `erase(x)` ลบข้อมูล `x` ออกจากโครงสร้างข้อมูล

สังเกตว่าเราสามารถใช้ array/vector ปกติในการ implement ได้ แต่จะต้องจัดเรียง/แทรก/ลบข้อมูลตลอด ทำให้เวลาในการทำงานเป็น `O(n)` สำหรับแต่ละ operation ซึ่งถือว่าช้าเกินไป โดยปกติแล้วเราจะ implement Set ADT โดยใช้ Binary Search Tree ซึ่งจะทำให้แต่ละ operation ทำงานในเวลา `O(log n)`

## Binary Search Tree

Binary Search Tree (BST) เป็นหนึ่งในวิธีการเก็บข้อมูลตามนิยามของ Set ADT นั่นคือสามารถค้นหา/เพิ่ม/ลบข้อมูลได้ โดยเฉลี่ยแล้วใช้เวลา `O(log n)` ต่อครั้ง มีวิธีการจัดการดังนี้

เราจะเก็บข้อมูลแต่ละตัวใน 1 node แต่ละ node จะมีข้อมูลตัวเลขนั้น และมี pointer ชี้ไปยัง node ลูกซ้ายและลูกขวา (left child และ right child) โดยเราต้องการให้ node ทุก node ที่อยู่ทางซ้ายมีค่าน้อยกว่า node นี้ ส่วน node ที่อยู่ทางขวาทุกมีค่ามากกว่า node นี้

หากลำดับที่ได้เป็น `1, 3, 4, 6, 7, 8, 10, 13, 14` รูปแบบ BST แบบหนึ่งที่เป็นไปได้อาจเป็นดังนี้

![](https://raw.githubusercontent.com/aquablitz11/toi14-tutorial/master/images/bst.png)

จากคุณสมบัติการเรียงข้อมูล เราสามารถตอบได้ว่ามีค่า `x` ใน BST หรือไม่ โดยเดินทางจาก root node (node บนสุด) ลงไปเรื่อย ๆ จนกว่าจะเจอ หาก `x` มีค่าน้อยกว่า root node เราจะต้องเดินทางไปทางซ้าย เพราะคำตอบจะไม่อยู่ทางขวาแน่นอน (อย่าลืมว่าทางขวาจะมีค่ามากกว่า root node เสมอ) แต่หาก `x` มีค่ามากกว่า root node ก็จะเดินทางไปทางขวา เป็นต้น

สำหรับการเพิ่มและลบข้อมูลสามารถทำได้โดยการหาตำแหน่งแล้วจัดการสร้าง node/ลบ node/ปรับ pointer ตามความเหมาะสม สำหรับรายละเอียดสามารถหาอ่านได้ในอินเทอร์เน็ต

อนึ่ง เวลาในการทำงานจะเป็น `O(log n)` ก็ต่อเมื่อ BST นั้น balanced นั่นคือ leaf node (node ปลายล่างสุด) ส่วนใหญ่อยู่ลึกลงไปในระดับเดียวกัน หากความลึกของต้นไม้อยู่ที่ประมาณ `O(log n)` แล้ว operation ต่าง ๆ ก็จะทำงานใน `O(log n)` ด้วย (เพราะเราจะต้องเดินทางลงไปตามจำนวนชั้น)

การสร้าง Balanced BST (BBST) นั้นสามารถทำได้โดยปรับรูปแบบการเก็บข้อมูลตลอดที่มีการเปลี่ยนแปลงข้อมูล โดย BBST มีหลายแบบ เช่น AVL Tree, Red-Black Tree เป็นต้น ส่วนใหญ่แล้ว BBST มีความยุ่งยากในการ implement สูงมาก ไม่เหมาะกับการแข่งขัน ดังนั้นปกติแล้วเราจะใช้ `set` ใน STL แทน (STL จัดการ implement ส่วนพวกนี้ไว้ให้หมดแล้ว)

## Hash Table

Hash Table เป็นอีกวิธีในการ implement Set ADT กล่าวคือ implement data structure ที่สามารถรองรับ operation `find`, `insert` และ `delete` ได้ แต่ Hash Table จะต่างจาก BST ตรงที่ไม่มีการเรียงข้อมูลจากมากไปน้อย

หลักการทำงานของ Hash Table จะเป็นดังนี้

-   กำหนด array ขึ้นมา ขนาดพอเหมาะ สมมุติว่าใช้ขนาด `n`
-   กำหนด hash function `H(x)` ขึ้นมา โดยสำหรับข้อมูล `x` ใด ๆ จะต้องหาค่า `H(x)` ได้เป็นคำตอบในช่วง `0` ถึง `n-1`
-   หากต้องการจะเพิ่มข้อมูล `x` เข้าใน hash table ให้นำไปจดไว้ที่ตำแหน่ง `H(x)` เลย (ถ้าเป็น array ปกติเราอาจจะจดเรียงตั้งแต่ตำแหน่ง 0 ถึง `n-1` ไป แต่ hash table จะใช้ค่า `H(x)` เป็นตัวกำหนดตำแหน่ง)
-   หากต้องการจะลบข้อมูล `x` ก็ให้ไปลบที่ตำแหน่ง `H(x)`
-   หากต้องการจะหาข้อมูล `x` ว่ามีหรือไม่ ให้ตรวจสอบที่ตำแหน่ง `H(x)` ว่ามีหรือไม่

สังเกตว่า hash function ของเราอาจจะทำให้ต้องนำข้อมูลไปใส่ไว้ในตำแหน่งเดียวกัน (เรียกว่า Hash Collision) ดังนั้น แทนที่แต่ละช่องของ array จะเก็บแค่จำนวนเดียว เราอาจจะแก้ปัญหาโดยใช้ `vector` แทนได้

ถ้าเราเลือก hash function ดีพอ ข้อมูลจะกระจายทั่วครบ `n` ช่องเป็นจำนวนเท่า ๆ กัน หากแต่ละช่องไม่มีข้อมูลซ้ำ หรือมีข้อมูลซ้ำน้อยมาก (เป็นค่าคงที่) เราอาจจะถือได้ว่า hash table รองรับ ทั้ง 3 operation ได้ในเวลา `O(1)`

ในที่นี้ขอไม่กล่าวถึงรายละเอียดการ implement เพราะ `unordered_set` ของ STL ได้ implement Hash Table ไว้อยู่แล้ว

## STL `set` และ `unordered_set`

สังเกตว่าข้อแตกต่างของ `set` และ `unordered_set` มีเพียงสองอย่างคือ

-   `set` จะเก็บข้อมูลแล้วจัดเรียงตลอด ในขณะที่ `unordered_set` ไม่ได้เรียงข้อมูล แต่เก็บตามตำแหน่งของค่า hash ที่ได้
-   `set` จะทำงานใน `O(log n)` โดยเฉลี่ย แต่ `unordered_set` จะทำงานใน `O(1)` หาก hash function ที่ STL มีให้ ดีพอ

โดยทั่วไป `unordered_set` ไม่ได้ดีกว่า `set` มากนัก เนื่องจาก `set` มีการเรียงข้อมูลจากน้อยไปมาก หากจำเป็นต้องไล่ข้อมูลเรียงตามลำดับบ่อย ๆ แนะนำให้ใช้ `set` เป็นหลัก ทั้งนี้แล้วแต่ความถนัด และความเหมาะสมที่จะนำมาใช้กับโจทย์ด้วย

ฟังก์ชันของ `set` และ `ordered_set` ที่เป็นไปได้ เช่น `insert`, `erase`, `count`, `size` ทั้งนี้ให้ศึกษาเองใน reference

ตัวอย่างการใช้งาน ดังนี้

```cpp
set<int> S;
S.insert(3);
S.insert(1);
printf("Found number %d: %s\n", 1, S.count(1) ? "True" : "False");
S.erase(3);
printf("Found number %d: %s\n", 3, S.count(3) ? "True" : "False");
```

อนึ่ง `set` และ `unordered_set` จะไม่รองรับการเก็บข้อมูลซ้ำกัน (หากพยายาม insert ข้อมูลซ้ำ จะไม่มีอะไรเกิดขึ้น) หากต้องการเก็บข้อมูลซ้ำครบทุกตัว จะต้องใช้ `multiset` หรือ `unordered_multiset` แทน

## ตัวอย่างการใช้ std::set ในการแก้โจทย์

กำหนดจำนวนเต็มมาให้ทั้งหมด N ตัว (N <= 1e5) แต่ละตัวมีค่าตั้งแต่ 0 ถึง 1e9 จงหาว่ามีจำนวนเต็มสองตัวจากตำแหน่งต่างกันที่มีค่ารวมกันเท่ากับ K หรือไม่ เช่น หากมีเลข [3, 2, 7, 6, 8] หาก K=5 จะตอบว่ามี (สร้างได้จาก 5=3+2) แต่ถ้า K=17 จะไม่มี

Naive Approoach (Time Limit Exceeded)

ลูปสองชั้น เพื่อเลือกว่าตัวแรกจะเอา index ใด ตัวที่สองจะเอา index ใด แล้วหาผลรวมว่าเท่ากับ K หรือไม่ ถ้าเท่าก็ตอบ Yes ถ้าลองทุกกรณีแล้วไม่มีให้ตอบ No

วิธีนี้จะใช้เวลา O(N^2) ซึ่งจะไม่ทันหาก N <= 1e5 (หากเราประมาณว่าคอมพิวเตอร์สามารถทำงานได้ 1e8 คำสั่งต่อวินาที วิธีนี้จะต้องใช้เวลามากถึง 100 วินาที)

Better Approach (Accepted)

แทนที่เราจะลูปชั้นที่สองเพื่อหาจำนวนที่นำมาบวกกับตัวแรกแล้วได้ K เราสามารถใช้ set เพื่อเก็บข้อมูลว่ามีตัวเลขที่เราต้องการหรือไม่ (เช่น หากเรากำลังพิจารณาเลข x ตัวก่อน ๆ หน้าที่เราเคยเจอมาควรจะมีเลข K-x อยู่ เพื่อที่จะบวกกันได้ K พอดี)

```cpp
bool sum_to_K(vector<int> A, int K) {
    set<int> S;
    for (int i = 0; i < A.size(); ++i) {
        if (S.count(K-A[i])) // หาว่ามีเลข K-A[i] ที่จะเอามาบวกกับ A[i] ได้ K พอดีหรือไม่
            return true;
        S.insert(A[i]); // เพิ่มไว้ใน set ว่าเคยเจอเลข A[i]
    }
    return false;
}
```

วิธีนี้ เนื่องจากว่าในการลูปแต่ละครั้งเราจะต้อง insert/count element ในเซตใช้เวลาครั้งละ O(log N) เวลารวมจึงเป็น O(N log N)

## Associative Array ADT

Associative Array เป็น Abstract Data Type ที่รองรับ operation คล้ายคลึงกับ array มาก แต่แทนที่จะใช้ index `0` ถึง `n-1` Associative Array จะอนุญาตให้ใช้ index อะไรก็ได้ ตามชนิดที่กำหนดไว้ ยกตัวอย่าง Associative Array `A` ที่มี index เป็น `string` และเก็บค่า `int` เราอาจจะใช้คำสั่ง `A["test"] = 1` ได้ เป็นต้น

การ implement Associative Array สามารถทำได้โดยดัดแปลงการเก็บข้อมูลของ Binary Search Tree คือจะเก็บข้อมูลเป็นคู่อันดับ `(key, value)` (`key` คือ index) เมื่อต้องการจัดการกับข้อมูลในตำแหน่ง `key` ก็เพียงแค่หาตำแหน่ง `key` ใน Binary Search Tree แล้วจัดการกับค่า `value` ที่เก็บไว้คู่กัน เนื่องจากว่าใช้ BST ดังนั้น ข้อมูลใน BST จะเรียงตาม `key` ด้วย ใน STL ได้ implement เป็น `map` ไว้ให้ใช้แล้ว

นอกจากนี้ อาจจะใช้ Hash Table ในการ implement โดยเก็บเป็นคู่อันดับคล้าย ๆ กัน ใน STL ได้ implement เป็น `unordered_map` ไว้ให้ใช้แล้ว

## STL `map` และ `unordered_map`

`map` และ `unordered_map` จะทำงานคล้ายกับ `set` และ `unordered_set` มาก แต่การ `insert` หรือ `erase` จะใช้เป็นคู่อันดับ `(key, value)` แทน นอกจากนี้ การเข้าถึงข้อมูล ณ index `key` สามารถใช้ได้เหมือน array ทั่วไปเลย (ความจริงแล้วไม่ต้องใช้ `insert` เลยก็ได้ สามารถกำหนดค่าเหมือน array ได้เลย)

ตัวอย่างการใช้งาน ดังนี้

```cpp
map<string, double> nums;
nums["pi"] = 3.1415926;
nums["e"] = 2.7182818;
string s = "pi";
printf("%.6f\n", nums[s]);
```

`map` และ `unordered_map` จะไม่รองรับการเก็บข้อมูลที่มี `key` ซ้ำกัน ซึ่งถือว่าปกติ เพราะ array ปกติ ช่องหนึ่งก็เก็บได้ค่าเดียวอยู่แล้ว ถึงอย่างไรก็ตามหากต้องการเก็บ `key` ซ้ำ สามารถใช้ `multimap` หรือ `unordered_multimap` แทนได้ แต่จะเสียคุณสมบัติความเป็น associative array ไป (ไม่สามารถเข้าถึงสมาชิกโดยใช้ `[]` ได้อีกแล้ว)

ทั้งนี้ ให้ศึกษาข้อมูลฟังก์ชันอื่น ๆ เพิ่มเติมจาก reference

Credits: aquablitz11
