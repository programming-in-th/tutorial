# Union-find Disjoint Set

Union-find Disjoint Set (DSU) เป็นโครงสร้างข้อมูลที่ใช้ในการเก็บข้อมูลการอยู่ร่วมกันเป็นกลุ่ม ๆ ของสิ่งของอะไรบางอย่าง โดยสิ่งของอย่างหนึ่งจะอยู่ได้ในกลุ่มเดียวเท่านั้น นอกจากนี้ อาจจะนำกลุ่มมารวมกันได้ตลอด ยกตัวอย่าง การจัด node ในกราฟเป็นกลุ่ม ๆ โดยให้ node ที่อยู่ใน component เดียวกันอยู่กลุ่มเดียวกัน และหากมีการเพิ่ม edge เปรียบเสมือนกันนำ 2 component นั้นมารวมกัน

สิ่งของในที่นี้ จะขอเรียกว่า node - DSU จะเก็บข้อมูลการอยู่ร่วมกันเป็นกลุ่ม โดยแต่ละกลุ่มจะมีตัวแทนกลุ่มอยู่ 1 node ส่วน node อื่น ๆ จะมี parent pointer ชี้ต่อกันไปเรื่อย ๆ จนไปถึงตัวแทนกลุ่ม (ส่วนตัวแทนกลุ่มชี้เข้าหาตนเอง)

เช่น หากกลุ่มหนึ่งมีสมาชิกเป็น `1, 2, 3, 4` โดยที่ `2` เป็นตัวแทนกลุ่ม จะได้ข้อมูล parent ดังนี้

-   `parent[2] = 2` (2 เป็นตัวแทนกลุ่มเลยชี้เข้าหาตนเอง)
-   `parent[1] = 2`
-   `parent[3] = 2`
-   `parent[4] = 3` (สังเกตว่า `4` ไม่ได้ชี้เข้าหา `2` โดยตรง แต่ชี้ที่ `3` แล้ว `3` ก็ชี้ต่อไปหา `2`)

เราจะกำหนดฟังก์ชัน `root(u)` เพื่อให้หาตัวแทนกลุ่มได้อย่างรวดเร็ว โดยเดินทางตาม `parent` ไปเรื่อย ๆ จนกว่าจะเจอ node ตัวแทน

```cpp
int root(int u) {
    if (parent[u] == u) // found
        return u;
    return root(parent[u]); // keep going
}
```

สังเกตว่าหากมีการชี้ต่อกันเป็นจำนวนมาก การค้นหาตัวแทนกลุ่มบ่อย ๆ จะใช้เวลานาน ดังนั้น เมื่อเจอตัวแทนกลุ่มของ node `u` แล้ว (สมมุติว่าเจอตัวแทนกลุ่มเป็น `r`) เราควรปรับให้ `parent[u] = r` เพื่อที่ครั้งหน้า เวลาเรียก `root(u)` จะได้หาตัวแทนกลุ่มได้ทันที เทคนิคนี้เรียกว่า Path Compression

```cpp
int root(int u) {
    if (parent[u] == u) // found
        return u;
    return parent[u] = root(parent[u]); // keep going
    // ^ notice parent[u] is set to the representative
}
```

ถ้าเราต้องการตรวจสอบว่า node `u` และ `v` อยู่กลุ่มเดียวกันหรือไม่ ก็สามารถตรวจสอบได้ง่าย ๆ โดยการหาตัวแทนกลุ่มทั้งคู่ หากตัวแทนกลุ่มเหมือนกัน ก็คืออยู่กลุ่มเดียวกัน

```cpp
bool is_same(int u, int v) {
    return root(u) == root(v);
}
```

หากเรามี node `u` และ `v` ซึ่งอยู่คนละกลุ่มกัน แล้วต้องการรวมสองกลุ่มเข้าด้วยกัน สามารถทำได้โดยให้ตัวแทนกลุ่มของ `u` ไปชี้ตัวแทนกลุ่มของ `v` (หรือจะสลับกันก็ได้)

```cpp
void merge(int u, int v) {
    u = root(u), v = root(v); // find representative first
    if (u == v) // already in same group
        return;
    parent[u] = v; // merging
}
```

เพียงแค่นี้้เราก็ได้ Union-find Disjoint Set แล้ว อนึ่ง อย่าลืมปรับ `parent[u] = u` ตอนเริ่มต้น เพราะว่าทุก node อยู่กลุ่มต่างกันหมด

อนึ่ง นอกจากเทคนิค Path Compression ที่ช่วยให้สามารถค้นหาตัวแทนกลุ่มได้อย่างรวดเร็วแล้ว ยังมีเทคนิค Union by Rank ซึ่งอาจจะช่วยลดเวลาการทำงานได้อีก (แต่ลดไม่มาก) โดยหลักการเป็นดังนี้

-   นอกจาก `parent` แล้ว แต่ละ node จะต้องเก็บ `rnk` (rank) อีกด้วย
-   สำหรับ node ที่ไม่ใช่ตัวแทนกลุ่ม เราจะไม่สนใจค่า `rnk`
-   ถ้า node เป็นตัวแทนกลุ่ม ค่า `rnk` จะต้องเท่ากับจำนวน node ในกลุ่มทั้งหมด
-   เมื่อนำตัวแทนกลุ่ม `u` และ `v` รวมเข้าด้วยกัน เราจะเลือกนำ node ที่มี `rnk` น้อย รวมเข้าสู่ node ที่มี `rnk` มากเสมอ (อย่าลืมปรับข้อมูล `rnk` ด้วย หลังรวมกลุ่มเสร็จ)

สังเกตว่าสิ่งที่ปรับเปลี่ยนมีเพียงแค่ array `rnk` ที่เพิ่มมา, ฟังก์ชัน `merge`, และการกำหนดให้ `rnk[u] = 1` สำหรับทุก node ตอนแรก (เพราะแต่ละ node อยู่กลุ่มที่มีแค่ตนเอง ก็คือมีสมาชิก 1 node)

```cpp
void merge(int u, int v) {
    u = root(u), v = root(v);
    if (u != v)
        continue;
    if (rnk[u] > rnk[v]) { // merge v into u
        rnk[u] += rnk[v];
        parent[v] = u;
    } else { // merge u into v
        rnk[v] += rnk[u];
        parent[u] = v;
    }
}
```

Data Structure นี้มีประโยชน์สำหรับ Kruskal's Algorithm ซึ่งมีไว้เพื่อหา Minimum Spanning Tree เป็นอย่างมาก ควรศึกษาสองอย่างนี้คู่กัน

Credits: aquablitz11
