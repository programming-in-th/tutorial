# Array และ Vector

## Array ใน C/C++

array เป็นรูปแบบการเก็บข้อมูลโดยเก็บข้อมูลเรียงเป็นตำแหน่งติด ๆ กันในหน่วยความจำ ทำให้สามารถเข้าถึงสมาชิก ณ ตำแหน่งใด ๆ ได้ในเวลา `O(1)` สำหรับการ implement เชื่อว่าน่าจะรู้กันดีอยู่แล้วว่าใช้ยังไง ดังนั้นขอกล่าวถึงเทคนิคที่แนะนำให้ใช้ในการทำโจทย์หลาย ๆ ข้อเท่านั้น ดังนี้

**1-based index**

โจทย์บางข้ออาจต้องการให้ใช้ index เป็นเลข `1` ถึง `n` แต่ตามปกติแล้ว array ขนาด `n` จะรองรับได้แค่เลข `0` ถึง `n-1` เท่านั้น มีวิธีแก้ปัญหาสองแบบคือ

-   เมื่อ input ต้องการให้จัดการกับข้อมูล ณ ตำแหน่ง `x` ก็ให้เลื่อนมาจัดการกับตำแหน่ง `x-1` ใน array จริง ๆ แทน
-   กำหนดขนาดของ array เป็น `n+1` เพื่อที่จะได้ใช้ตำแหน่ง `n` ได้ ส่วนตำแหน่ง `0` เราจะไม่พิจารณาเลย

**Global Constant-sized Array**

แทนที่จะประกาศ array ไว้ในฟังก์ชัน `main` แล้วส่งเป็น argument เมื่อจะเรียกฟังก์ชัน ควรประกาศ array ทุกอย่างไว้ใน global scope เลยเพื่อที่จะเข้าถึงได้ง่าย นอกจากนี้การประกาศใน global scope จะทำให้ค่าของ array ทุกช่องเป็น 0 โดยอัตโนมัติอีกด้วย (หากเป็น `char` ก็จะได้ `\0`, `bool` จะได้ `false` เป็นต้น)

สำหรับขนาดของ array ควรประกาศไว้เป็นค่าคงที่ โดยประกาศเป็นขนาดที่มากพอที่จะรองรับ input ของโจทย์ได้ อาจจะประกาศเผื่อไว้ด้วยเพื่อป้องกันความผิดพลาด เช่น หากโจทย์มี input ที่ `n <= 100000` ควรประกาศ array ขนาด 100,010 เป็นต้น

## Dynamic Array

Dynamic array โดยนิยามแล้วคือ array ที่สามารถขยายขนาดได้ ใน STL ของ C++ เราสามารถใช้ dynamic array ได้โดยการใช้ vector ซึ่ง API documentation สามารถหาได้ที่ [เว็บนี้](http://www.cplusplus.com/reference/vector/vector/)

ฟังก์ชันที่มี เช่น `push_back`, `pop_back`, `insert`, `erase`, `size` เป็นต้น สำหรับรายละเอียดการใช้งานให้อ่านใน reference ด้วยตนเอง

### ทำไมถึงต้องใช้ dynamic array?

ปัญหาหลักของการใช้ array ธรรมดาคือการที่ขนาดของ array ไม่สามารถเปลี่ยนแปลงได้ ทั้งนี้มีหลายปัญหาที่ต้องการใช้ array ที่เปลี่ยนขนาดได้ เช่นถ้าหากเราต้องการที่จะเก็บข้อมูลเกี่ยวกับกองหนังสือกองหนึ่งที่ผู้ใช้สามารถใส่ทับหรือหยิบออกจากด้านบนได้โดยที่เราไม่รู้ว่าจำนวนหนังสือในกองมากที่สุดที่เป็นไปได้คือเท่าใด เราก็ไม่สามารถใช้ array ธรรมดาได้ เนื่องจากจำนวนหนังสือในกองอาจเกินความยาวของ array ฉนั้นเราต้องใช้ dynamic array มาช่วย

### วิธีการจัดสรรหน่วยความจำของ dynamic array

เนื่องจาก array ธรรมดาไม่สามารถขยายความยาวได้ ดังนั้นเมื่อเราเติมข้อมูลถึงจุดที่ความยาวใกล้จะเกินแล้ว เราก็สามารถสร้าง array ใหม่ที่มีความยาวสองเท่าของ array เดิม แล้วก็ย้ายข้อมูลจาก array เดิมเข้าไปใน array ตัวใหม่ ถ้าหากตอนแรกเรามี array `A[4] = {1, 2, 3, 4}` และต้องการที่จะเพิ่ม `5` เข้าไปใน `A` เราก็จะสร้าง array `B = {1, 2, 3, 4, null, null, null, null}` และเปลี่ยน `B[5] = 5` จึงได้ `B = {1, 2, 3, 4, 5, null, null, null}`

เราสามารถเขียนอัลกอริทึมของการใส่ข้อมูลใหม่นี้ในรูปแบบทั่วไปได้ดังนี้

1. ให้ array `A` ขนาด `n` มา
2. ถ้าหากจำนวนของใน `A` ยังน้อยกว่าขนาดของ `A` ให้ใส่ในช่องว่างช่องแรก
3. มิเช่นนั้นให้สร้้าง array `B` ขึ้นมาที่มีขนาดเท่ากับ `2n`
4. ย้ายข้อมูลจาก `A` ไป `B` ทั้งหมด
5. ใส่ข้อมูลใหม่ในช่องว่างช่องแรกของ `B`

ทั้งนี้คือวิธีการที่ dynamic array จัดสรรหน่วยความจำของ dynamic array ภายใน แต่ในการใช้จริง เรามันจะใช้ API ของ STL โดยตรง

### เวลาการทำงานของ dynamic array

แม้่ว่าอัลกอริทึมในการ resize array อาจจะดูเหมือนไม่มีประสิทธิภาพ แต่อย่างไรก็ตามเราสามารถพิสูจน์ได้ว่าโดยรวมแล้วการ resize จะใช้เวลาการทำงานเท่ากับ $O(1)$ ต่อหน่วยข้อมูล หรือกล่าวในอีกนัยนึงคือ amortized compleixty ของอัลกอริทึมคือ $O(1)$

นิยาม $n$ เท่ากับความยาว array หลังการ resize ทั้งหมด และ $m$ เท่ากับจำนวนครั้งที่เกิดการ resize เราจะสามารถเห็นได้ว่า $m$ จะเป็น $O(\log_{2}{n})$ เนื่องจากเราจะ resize เป็นสองเท่าของความยาวเดิมเสมอ ฉนั้นในแต่ละขั้นตอน ขนาดของ array จะเท่ากับ $2^i$ โดยที่ $0 \leq i < m$

ฉนั้นการทำงานทั้งหมดจะใช้เวลาเท่ากับ

$$
\begin{align*}
T(n) &= O(2^0 + 2^1 + 2^2 + \dots + 2^{m-1}) \\
&= O(\frac{2^m - 1}{2 - 1}) \\
&= O(2^{\log_{2}{n} - 1}) \\
&= O(n)
\end{align*}
$$

ฉนั้นการทำงานต่อหนึ่งหน่วยข้อมูลเท่ากับ $O(1)$

Credits: aquablitz11
