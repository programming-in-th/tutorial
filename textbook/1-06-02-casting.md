## 1.6.2 Implicit Type Casting

สมมุติว่าเรามีโค้ดดังต่อไปนี้
```cpp
int x = 10;
double y = 3.14;
```
หากเราต้องการจะแสดงผลค่า `x+y` จะต้องใช้ format ประเภทใด: `%d` (จำนวนเต็ม) หรือ `%f` (ทศนิยม)

ภาษา C จะทำการแปลงชนิดตัวแปรให้อัตโนมัติเมื่อเรานำตัวแปรต่างชนิดมาดำเนินการร่วมกัน ในกรณีนี้ จำนวนเต็ม (`int`) เมื่อนำมาดำเนินการกับทศนิยม (`double`) จะได้ทศนิยม (`double`) เสมอ ดังนั้น หากต้องการแสดงผลให้ถูกต้อง จะต้องเก็บใส่ตัวแปร `double` ดังนี้
```cpp
double sum = x+y;
printf("%f", sum);
```

โดยทั่วไป ภาษา C จะพยายามแปลงจากตัวแปรที่เล็กกว่าไปตัวแปรที่ใหญ่กว่าเสมอ
ระหว่างจำนวนเต็มกับทศนิยม จะแปลงไปเป็นทศนิยม เพื่อไม่ให้ข้อมูลหลังจุดทศนิยมสูญหาย
ระหว่างตัวแปรที่เก็บค่าได้น้อยกว่ากับมากกว่า จะแปลงไปเป็นตัวแปรที่เก็บค่าได้มากกว่าเสมอ (เช่น `int` กับ `long long` จะกลายเป็น `long long`)

---

การแปลงแบบอัตโนมัติจะเกิดขึ้นอีกกรณีหนึ่งเมื่อใช้ชนิดตัวแปรกับค่าข้อมูลไม่ตรงกัน เช่น
```cpp
int x = 4.9;
printf("%d", x);
```
ในกรณีนี้ 4.9 (`double`) จะถูกบีบให้เหลือเพียงแค่จำนวนเต็ม (`int`) ดังนั้น เมื่อแสดงผลออกมาจะได้ค่าเท่ากับ 4 เท่านั้น (ปัดลงเสมอ)

อีกกรณีหนึ่ง เช่น
```cpp
int x = 100000000000;
printf("%d", x);
```
ค่าดังกล่าวเกินขอบเขตของ `int` ดังนั้น จะเกิดการ overflow ทำให้คำตอบออกมาคลาดเคลื่อน (กรณีนี้จะได้คำตอบเป็น 1215752192)

---

กลับมาที่ปัญหาเดิมของเรา หากเราต้องการจะให้คำตอบของ 7 หารด้วย 3 ออกมาเป็นทศนิยมเท่ากับ 2.333 เราสามารถใช้ implicit casting มาช่วยได้

**โจทย์**: จงแก้โค้ดดังกล่าวเพื่อให้คำตอบออกมาเป็นทศนิยม (พยายามแก้ให้น้อยที่สุด)
```cpp
int x = 7;
double ans = x/3;
printf(“%f”, ans);
```

**เฉลย**: มีสามวิธีด้วยกัน
- แก้ `x` ให้เป็นตัวแปรประเภท `double`
- แก้ `3` เป็น `3.0` (`double`) เพื่อให้ `x/3` เป็น `int/double = double`
- เขียนเป็น `x*1.0/3` หรือ `x/(3*1.0)` เพื่อให้โปรแกรมคำนวณ `x*1.0` (หรือ `3*1.0`) ก่อน จะได้กลายเป็น `double` แล้วเมื่อนำไปหาร `y` ซึ่งเป็น `int` ก็จะได้ `double`
(ใช้ `x/3*1.0` ไม่ได้ เพราะหากคำนวณจากซ้ายมาขวา `x/3` จะได้ `int` ทำให้สูญเสียข้อมูลทศนิยมไป ถึงจะนำมาคูณ `1.0` ทีหลังก็สายเสียแล้ว)
