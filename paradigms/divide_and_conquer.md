# Divide and Conquer

แนวคิดหลัก ๆ ของ Divide and Conquer คือ แบ่งปัญหาออกเป็นหลายส่วนที่เท่า ๆ กัน ใช้อัลกอริทึมเดิมแก้ปัญหาย่อย ๆ ซ้ำแบบ recursive แล้วหาวิธีรวมคำตอบเข้าด้วยกัน เป็นคำตอบของปัญหาใหญ่ (โดยส่วนใหญ่ จะแบ่งออกเป็น 2 ส่วนเท่า ๆ กัน)

ยกตัวอย่างอัลกอริทึม Divide and Conquer เช่น Merge Sort ที่ใช้การ sort array ครึ่งแรกกับครึ่งหลังแยกกัน แล้วค่อยนำ array ทั้งสองมารวมกัน เนื่องจากว่ามีการแบ่งครึ่งลงไปทั้งหมด `O(log n)` ชั้น แต่ละชั้นจะต้องจัดการกับสมาชิกของ array เพื่อทำการรวม array - รวมทั้งหมด `O(n)` ตัว ทำให้เวลาการทำงานของ merge sort เป็น `O(n log n)`

ในการแข่งขัน TOI ปกติจะไม่ค่อยเจอโจทย์ Divide and Conquer ท่าแปลก ๆ มาก ยกเว้นการ Binary Search บนปัญหา Optimization Problem ที่ถูกแปลงเป็น Decision Problem ซึ่งพบได้บ่อยมาก ควรศึกษาไว้

## Binary Search

> กำหนดลำดับจำนวนให้ทั้งหมด `n` ตัว มีคำถามให้ `q` คำถาม แต่ละคำถาม ให้หาว่ามีเลข `x` อยู่ในลำดับหรือไม่

เราสามารถ sort array ดังกล่าวเรียงจากน้อยไปมากก่อน แล้วสำหรับแต่ละคำถาม เราจะมีวิธีดังนี้
- ตอนแรก ดูตำแหน่งกลางของ array ก่อน หากตัวเลขตรงกับตัวที่ต้องการหา ก็จบการทำงาน ตอบได้ว่ามีตัวเลขดังกล่าว
- หากไม่ใช่ ให้ดูว่าตัวเลขที่เราต้องการมีค่าน้อยกว่าหรือมากกว่าตัวเลขตำแหน่งตรงกลาง
- หากตัวเลขที่เราต้องการมีค่าน้อยกว่า แสดงว่าอาจจะอยู่ทางซ้าย เราจะมาค้นหาในช่วงครึ่งซ้ายแทน แต่หากมากกว่า ให้ค้นหาในช่วงครึ่งขวา
- การค้นหาแต่ละช่วง จะใช้ดูค่าตรงกลาง แล้วเลือกครึ่งที่สมควรค้นหาเรื่อย ๆ เช่นเดียวกัน

สังเกตว่าแต่ละครั้ง array ของเราจะถูกตัดออกไปทีละครึ่ง ดังนั้น รวมแล้วจะใช้เวลาไม่เกิน `O(log n)` ในการตอบคำถามแต่ละครั้ง

## การแปลง Optimization Problem เป็น Decision Problem

ปัญหาที่ต้องการให้หาค่าน้อยสุด/มากสุดบางอย่าง สามารถแปลงมาเป็นปัญหาการตัดสินใจ (ที่ต้องตอบ Yes/No) เพื่อที่จะทำให้หาคำตอบโดยการ binary search ได้ ทำให้แก้ปัญหาได้ง่ายขึ้น ยกตัวอย่างดังนี้

> มีลำดับจำนวนเต็มบวกอยู่ `n` ตัว ต้องการแบ่งเป็นช่วง ๆ โดยจะมีค่า `x` กำหนดไว้ แต่ละช่วงจะต้องมีผลรวมของสมาชิกไม่เกิน `x` ถามว่า หากเราต้องการแบ่งออกเป็นช่วงไม่เกิน `k` ช่วง เราสามารถกำหนดค่า `x` ให้น้อยสุดได้เท่าไหร่

ยกตัวอย่าง หากมีลำดับ `3, 5, 1, 2, 4` และ `k = 2` หากเรากำหนดให้ `x = 7` จะพบว่า การแบ่งโดยให้แต่ละช่วงมีผลรวมไม่เกิน `x = 7` จะต้องใช้อย่างน้อย 3 ช่วง เช่น `[3], [5], [1, 2, 4]` - ค่า `x` นี้ใช้ไม่ได้ เพราะเราต้องการแบ่งเป็นช่วงไม่เกิน `k = 2` ช่วง

หากเรากำหนดให้ `x = 8` พบว่าเราสามารถแบ่งเป็น `[3, 5], [1, 2, 4]` ซึ่งใช้เพียง `k = 2` ช่วงเท่านั้น ไม่ขัดกับเงื่อนไขโจทย์

สังเกตว่า หากเราเปลี่ยนปัญหาจาก "หาค่า `x` ที่น้อยสุดที่เป็นไปได้" เป็น "ตรวจสอบว่า ถ้าแบ่งให้แต่ละช่วงมีผลรวมไม่เกิน `x` จะแบ่งให้มีไม่เกิน `k` ช่วงได้หรือไม่" เราจะตอบปัญหาแบบหลังได้ง่ายขึ้น

การตรวจสอบว่าทำได้หรือไม่ สามารถทำได้แบบ greedy - เริ่มต้นมา ให้ช่วงแรกประกอบด้วยจำนวนตัวแรกเพียงตัวเดียว พยายามเพิ่มตัวถัดไปเรื่อย ๆ ตราบใดที่ผลรวมยังไม่เกิน `x` - ถ้าเกินแล้ว ให้เริ่มต้นช่วงใหม่ - ทำไปเรื่อย ๆ จนครบทุกตัว แล้วตรวจสอบว่าจำนวนช่วงเกิน `k` หรือไม่

เมื่อเราสามารถตรวจสอบคำตอบได้อย่างง่ายดาย การที่จะแก้ปัญหาดั้งเดิมได้นั้น ก็เพียงแค่ binary search บนค่า `x` โดยมีเงื่อนไขดังนี้
- เริ่มต้นมา พิจารณาช่วงค่า `x` ที่เป็นไปได้ตั้งแต่ `1` ถึง `INF` (เมื่อ `INF` คือ bound ผลรวมที่มากที่สุดที่เป็นไปได้ของ array ทั้ง array)
- ทดลองค่า `x` ตรงกลางช่วง หากตรวจสอบแล้วสามารถทำให้เงื่อนไขเป็นจริงได้ สังเกตว่าถ้าเราเพิ่มค่า `x` ยังไงเงื่อนไขก็ยังเป็นจริงอยู่ แต่เราต้องการค่า `x` น้อยสุด ดังนั้น เราจะพิจารณาเฉพาะช่วงคำตอบ `x` ตั้งแต่ 1 ถึงค่าดังกล่าว (เผื่อทำให้ `x` น้อยกว่านี้ได้อีก)
- หากทดลองแล้วพบว่าเงื่อนไขเป็นเท็จ นั่นแปลว่าเราจำเป็นต้องเพิ่มค่า `x` เพราะฉะนั้น เราจะพิจารณาค่า `x` ที่เป็นไปได้ ตั้งแต่ ค่าดังกล่าวบวก 1 ถึง `INF`
- เราจะแบ่งครึ่งช่วงไปเรื่อย ๆ จนกว่าจะเหลือเพียงค่าเดียว ได้เป็นคำตอบของคำถามดังกล่าว

```cpp
#include <bits/stdc++.h> // <- include everything
using namespace std;

const int N = 100010;
const long long INF = 1e18;

int n, k;
long long val[N];

bool check(long long limit)
{
    int cnt = 1;
    long long sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (val[i] > limit)
            return false;
        // เริ่มต้นช่วงใหม่ ถ้าเพิ่มตัวใหม่เข้าไปแล้วทำให้ผลรวมเกิน
        if (sum + val[i] > limit) {
            ++cnt;
            sum = 0;
        }
        sum += val[i];
    }
    return cnt <= k;
}

int main()
{
    scanf("%d%d", &k, &n);
    for (int i = 1; i <= n; ++i)
        scanf("%lld", &val[i]);
    
    long long lo = 1;
    long long hi = INF;
    while (lo < hi) {
        long long mid = (lo+hi)/2;
        if (check(mid))
            hi = mid;
        else
            lo = mid+1;
    }
    printf("%lld\n", lo);
    
    return 0;
}
```

Credits: [toi14-tutorial](https://github.com/aquablitz11/toi14-tutorial) by aquablitz11