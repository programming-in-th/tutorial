# Brute Force

Brute Force เป็นวิธีการแก้ปัญหาที่ง่ายที่สุด เพราะไม่จำเป็นต้องคิดวิธีที่ดีอะไรมาก เพียงแค่ทดลองทุกคำตอบ/ทุกกรณีที่เป็นไปได้ แล้วตอบคำตอบที่ดีที่สุด (หรือตอบจำนวนวิธีที่เป็นไปได้ หากโจทย์ถามหาจำนวนวิธีในการทำอะไรบางอย่าง) จะหนักที่การ implement ซะมากกว่า

ถึงโจทย์ส่วนใหญ่จะให้คะแนนวิธีนี้น้อย เราควรศึกษาและฝึก implement Brute Force ให้ดี ๆ เพราะหากหาวิธีที่ดีไม่ได้ การทำ Brute Force ก็อาจจะช่วยให้ได้คะแนนได้บางส่วน

## Iterative Complete Search

โจทย์บางข้อสามารถ Brute Force ได้โดยการทดลองลูปบนคำตอบทั้งหมดที่เป็นไปได้ โดยอาจจะลูปหลายชั้น เช่น

> กำหนดลำดับตัวเลขมาให้ `n` ตัว ให้เลือกตัวเลขสองตัวที่มีค่าต่างกันน้อยที่สุดที่เป็นไปได้

วิธีหนึ่งที่ทำได้ คือลูปสองชั้นเพื่อทดลองเลือกตัวเลขสองตัวทุกแบบที่เป็นไปได้ หาวิธีการเลือกที่ได้ค่าแตกต่างกันน้อยที่สุดแล้วตอบ

> กำหนดจำนวนเต็ม `A` และ `B` ให้ จงหาจำนวนเต็มบวก `x` และ `y` ทุกคู่ที่ตรงตามเงื่อนไข `x+y = A` และ `x*y = B`

ใช้การทดลองลูปสองชั้นเพื่อทดลองค่า `x`, `y` ทั้งหมดที่เป็นไปได้ (ไม่เกิน `A` หรือ `B`) แล้วตรวจสอบเงื่อนไขทั้งสองเงื่อนไข ถ้าตรงเงื่อนไขก็ตอบคู่นั้น วิธีนี้จะใช้เวลา `O(min(A, B)^2)`

สังเกตว่าความจริงแล้วเราไม่จำเป็นต้องลูปค่า `y` ก็ได้ เพราะหากเลือกค่า `x` แล้ว เราสามารถสรุปได้ทันทีว่า `y = A-x` ตามสมการแรก สิ่งที่ต้องทำมีเพียงแค่การตรวจสอบเงื่อนไข `x*y = B` ว่าเป็นจริงหรือไม่ วิธีนี้จะใช้เวลา `O(min(A, B))`

## Recursive Complete Search

โจทย์บางข้อจำเป็นต้องทดลองวิธีเป็นจำนวนมาก และไม่สามารถใช้ลูปหลายชั้นในการแก้ได้ ดังนั้นจึงต้องเขียน recursive function เพื่อทดลองเลือกทุกวิธีที่เป็นไปได้แทน

**Perket - COCI 2008/2009, Contest #2**

> ต้องการทำอาหาร มีส่วนผสมให้ทั้งหมด `n` ชิ้น (`n <= 10`) โดยส่วนผสมแต่ละชิ้นจะมีค่าความเปรี้ยวและค่าความขม ให้เลือกส่วนผสมมาทำอาหาร (เลือกกี่ชิ้นก็ได้ แต่ต้องอย่างน้อย 1 ชิ้น) เมื่อทำอาหาร จะได้อาหารที่มีค่าความเปรี้ยวเท่ากับผลคูณของค่าความเปรี้ยวของส่วนผสมที่เลือกมา ส่วนค่าความขมจะเท่ากับผลบวกของค่าความขมของส่วนผสมที่เลือกมา ให้หาวิธีเลือกโดยให้ความต่างระหว่างค่าความขมกับค่าความเปรี้ยวน้อยที่สุดเท่าที่เป็นไปได้
>

สังเกตว่าเราต้องการทดลองเลือกทุกสับเซตที่เป็นไปได้ (ยกเว้นเซตว่าง) แล้วหาสับเซตที่มีค่าความต่างน้อยที่สุด วิธีการหนึ่งที่เป็นไปได้คือการเลือกตัดสินใจว่า ชิ้นที่ 1 จะเอาหรือไม่ ชิ้นที่ 2 จะเอาหรือไม่, ..., ชิ้นที่ `n` จะเอาหรือไม่

ในการทดลอง เราสร้าง array ของ `bool` ชื่อ `picked` ขึ้นมา โดยนิยามให้ `picked[i]` เป็น `true` ถ้าเลือกใช้ส่วนผสมชิ้นที่ `i` และเป็น `false` ถ้าไม่เลือกใช้

ต่อมา กำหนดฟังก์ชัน recursive ชื่อ `pick(i)` ซึ่งจะทำหน้าที่กำหนดค่าให้ `picked[i]` เป็น `true`, เรียก `pick(i+1)` เพื่อทำการเลือกส่วนผสมชิ้นถัด ๆ ไปทุกแบบที่เป็นไปได้ เมื่อ return กลับมาแล้วจึงกำหนดค่าให้ `picked[i]` เป็น `false` แล้วเรียก `pick(i+1)` เพื่อทดลองทุกความเป็นไปได้เช่นเดียวกัน

ในกรณีที่เรียก `pick(n+1)` จะถือว่าทดลองเลือกของมาแล้ววิธีหนึ่งตามที่ระบุใน array `picked`, ฟังก์ชันจะทำการคำนวณค่าความต่าง พร้อมเช็คเงื่อนไขเพื่อให้มั่นใจว่าไม่ได้เลือกเซตว่างมา หากค่าความต่างน้อยกว่าค่าความต่างน้อยสุดที่เคยเก็บไว้ ก็ให้จดคำตอบใหม่

ดูโค้ดตัวอย่างด้านล่าง

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 20;
const int INF = 1e9;

int n;
int sour[N], bitter[N];
bool picked[N];
int ans = INF;

void pick(int i)
{
    if (i <= n) {
        picked[i] = true;
        pick(i+1);
        picked[i] = false;
        pick(i+1);
    } else { // i == n+1
        int total_sour = 1, total_bitter = 0, count_used = 0;
        for (int j = 1; j <= n; ++j) {
            if (picked[j]) {
                ++count_used;
                total_sour *= sour[j];
                total_bitter += bitter[j];
            }
        }
        if (count_used != 0)
            ans = min(ans, abs(total_sour - total_bitter));
    }
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d%d", &sour[i], &bitter[i]);
    pick(1);
    printf("%d\n", ans);
    
    return 0;
}
```

**Bond - COCI 2006/2007, Contest #1**

> กำหนดตารางขนาด `n*n` ให้ แต่ละช่องมีจำนวนเต็มกำกับอยู่ แสดงถึงความน่าจะเป็น มีค่าตั้งแต่ 0 ถึง 100 ให้เลือกตัวเลขในตารางมา `n` ตัว โดยที่ตัวเลขที่เลือกจะต้องไม่มีตัวใดอยู่ในแถวเดียวกันหรือหลักเดียวกัน จงหาว่าจะสามารถเลือกให้ได้ผลคูณของความน่าจะเป็นมากที่สุดเท่าใด (ตอบเป็นทศนิยม 6 หลัก มีค่าตั้งแต่ 0 ถึง 100)

การเลือกที่ตรงตามเงื่อนไขโจทย์นั้น แต่ละแถวจะมีคอลัมน์ที่ถูกเลือกคอลัมน์หนึ่งพอดี และจะไม่มีคอลัมน์ใดถูกเลือกซ้ำกัน หากแก้โจทย์ข้อนี้โดยใช้ Brute Force เราอาจทำได้โดยการเขียนฟังก์ชันเพื่อทดลองเลือกคอลัมน์ให้กับแต่ละแถว แล้วตรวจสอบว่ามีการเลือกคอลัมน์ซ้ำกันหรือไม่ ถ้าไม่มีการเลือกซ้ำกัน ให้จดคำตอบที่ดีที่สุดที่เป็นไปได้ (ผลคูณที่มากสุดที่เป็นไปได้)

สังเกตว่า เราไม่จำเป็นต้องเช็คเงื่อนไขตอนจบเพียงอย่างเดียวก็ได้ แต่ตรวจสอบเงื่อนไขขณะที่เลือกได้เลย ถ้าพบว่าเลือกแล้วผิดเงื่อนไขก็ให้ข้ามตัวเลือกนั้น วิธีนี้เรียกว่า Recursive Backtracking

โค้ดตัวอย่างดังนี้

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 21;

int n;
double A[N][N];
bool used[N];
double ans = 0;

// i = current row, prod = product of picked values
void solve(int i, double prod) {
    if (i == n+1) {
        ans = max(ans, prod);
        return;
    }
    // try picking each column
    for (int j = 1; j <= n; ++j) {
        if (used[j]) // can't pick already-used column
            continue;
        // if can pick, try picking then call recursively
        used[j] = true;
        solve(i+1, prod*A[i][j]);
        used[j] = false;
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            scanf("%lf", &A[i][j]);
            A[i][j] /= 100; // must convert to real number in [0, 1]
        }
    }
    solve(1, 1.0);
    printf("%.6f\n", ans*100.0); // must convert back to range [0, 100]
    return 0;
}
```

**N-Queen Problem**

> มีกระดานหมากรุกขนาด `n*n` ให้วาง Queen ทั้งหมด `n` ตัวโดยที่ Queen แต่ละตัวต้องไม่ attack Queen ตัวอื่น (จะ attack ก็ต่อเมื่ออยู่ในแถว/คอลัมน์/แนวทแยงเดียวกันเท่านั้น)

แต่ละแถว จะต้องเลือกตำแหน่งให้ queen อยู่ ณ คอลัมน์ใดคอลัมน์หนึ่ง โดยเมื่อเลือกเสร็จแล้ว ต้องตรวจสอบว่าแต่ละคอลัมน์ถูกเลือกเพียงครั้งเดียวเท่านั้น นอกจากนี้ queen แต่ละตัวต้องไม่อยู่ในแนวทแยงเดียวกันกับ queen ตัวอื่น ๆ ด้วย หากไม่ขัดเงื่อนไขก็สามารถตอบวิธีการวางดังกล่าวได้

สังเกตว่าสามารถทำคล้าย ๆ ข้อ Bond ได้ นั่นคือทำ Recursive Backtracking - ระหว่างเลือก ต้องตรวจสอบว่าไม่ได้ใช้คอลัมน์ซ้ำกับ queen ตัวอื่น และไม่ได้อยู่ในแนวทแยงเดียวกันกับ queen ตัวอื่นเช่นกัน

## Simulation

โจทย์บางข้อกำหนดสถานการณ์มาให้ แล้วคุณต้องตอบคำถามตามที่โจทย์กำหนด วิธีที่ง่ายที่สุดวิธีหนึ่งคือการ implement โค้ดเพื่อจำลองสถานการณ์แล้วตอบคำถาม

> กำหนดลำดับจำนวนเต็ม `1` ถึง `n` มาให้ ให้ทำการ sort array ดังกล่าวด้วย bubble sort - มีคำถามมาให้ `q` คำถาม แต่ละคำถามถามว่า ใน bubble sort pass ที่ `k` ตัวเลข `x` อยู่ที่ตำแหน่งใด

เราอาจจะสร้าง array 2 มิติขึ้นมาเพื่อเก็บสภาพของ array หลังการ bubble sort แต่ละรอบ แล้วตอบคำถามแต่ละคำถาม

Credits: [toi14-tutorial](https://github.com/aquablitz11/toi14-tutorial) by aquablitz11