# Dynamic Arrays

Dynamic array โดยนิยามแล้วคือ array ที่สามารถขยายขนาดได้ ใน STL ของ C++ เราสามารถใช้ dynamic array ได้โดยการใช้ vector ซึ่ง API documentation สามารถหาได้ที่ [เว็บนี้](http://www.cplusplus.com/reference/vector/vector/)

## ทำไมถึงต้องใช้ dynamic array?

ปัญหาหลักของการใช้ array ธรรมดาคือการที่ขนาดของ array ไม่สามารถเปลี่ยนแปลงได้ ทั้งนี้มีหลายปัญหาที่ต้องการใช้ array ที่เปลี่ยนขนาดได้ เช่นถ้าหากเราต้องการที่จะเก็บข้อมูลเกี่ยวกับกองหนังสือกองหนึ่งที่ผู้ใช้สามารถใส่ทับหรือหยิบออกจากด้านบนได้โดยที่เราไม่รู้ว่าจำนวนหนังสือในกองมากที่สุดที่เป็นไปได้คือเท่าใด เราก็ไม่สามารถใช้ array ธรรมดาได้ เนื่องจากจำนวนหนังสือในกองอาจเกินความยาวของ array ฉนั้นเราต้องใช้ dynamic array มาช่วย

## วิธีการจัดสรรหน่วยความจำของ dynamic array

เนื่องจาก array ธรรมดาไม่สามารถขยายความยาวได้ ดังนั้นเมื่อเราเติมข้อมูลถึงจุดที่ความยาวใกล้จะเกินแล้ว เราก็สามารถสร้าง array ใหม่ที่มีความยาวสองเท่าของ array เดิม แล้วก็ย้ายข้อมูลจาก array เดิมเข้าไปใน array ตัวใหม่ ถ้าหากตอนแรกเรามี array `A[4] = {1, 2, 3, 4}` และต้องการที่จะเพิ่ม `5` เข้าไปใน `A` เราก็จะสร้าง array `B = {1, 2, 3, 4, null, null, null, null}` และเปลี่ยน `B[5] = 5` จึงได้ `B = {1, 2, 3, 4, 5, null, null, null}`

เราสามารถเขียนอัลกอริทึมของการใส่ข้อมูลใหม่นี้ในรูปแบบทั่วไปได้ดังนี้

1. ให้ array `A` ขนาด `n` มา
2. ถ้าหากจำนวนของใน `A` ยังน้อยกว่าขนาดของ `A` ให้ใส่ในช่องว่างช่องแรก
3. มิเช่นนั้นให้สร้้าง array `B` ขึ้นมาที่มีขนาดเท่ากับ `2n`
4. ย้ายข้อมูลจาก `A` ไป `B` ทั้งหมด
5. ใส่ข้อมูลใหม่ในช่องว่างช่องแรกของ `B` 

ทั้งนี้คือวิธีการที่ dynamic array จัดสรรหน่วยความจำของ dynamic array ภายใน แต่ในการใช้จริง เรามันจะใช้ API ของ STL โดยตรง

## เวลาการทำงานของ dynamic array

แม้่ว่าอัลกอริทึมในการ resize array อาจจะดูเหมือนไม่มีประสิทธิภาพ แต่อย่างไรก็ตามเราสามารถพิสูจน์ได้ว่าโดยรวมแล้วการ resize จะใช้เวลาการทำงานเท่ากับ $O(1)$ ต่อหน่วยข้อมูล หรือกล่าวในอีกนัยนึงคือ amortized compleixty ของอัลกอริทึมคือ $O(1)$

นิยาม $n$ เท่ากับความยาว array หลังการ resize ทั้งหมด และ $m$ เท่ากับจำนวนครั้งที่เกิดการ resize เราจะสามารถเห็นได้ว่า $m$ จะเป็น $O(\log_{2}{n})$ เนื่องจากเราจะ resize เป็นสองเท่าของความยาวเดิมเสมอ ฉนั้นในแต่ละขั้นตอน ขนาดของ array จะเท่ากับ $2^i$ โดยที่ $0 \leq i < m$

ฉนั้นการทำงานทั้งหมดจะใช้เวลาเท่ากับ
$$T(n) = O(2^0 + 2^1 + 2^2 + \dots + 2^{m-1})$$

$$= O(\frac{2^m - 1}{2 - 1})$$

$$= O(2^{\log_{2}{n} - 1})$$

$$= O(n)$$

ฉนั้นการทำงานต่อหนึ่งหน่วยข้อมูลเท่ากับ $O(1)$