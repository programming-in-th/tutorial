# Shortest Path Algorithm

หลัก ๆ แล้วเขียนแค่ Dijkstra’s Algorithm เป็นก็พอ ส่วน Bellman-Ford ควรรู้ไว้เผื่อโจทย์มี edge ที่มี negative weight

Floyd-Warshall ไม่จำเป็นก็ได้ แต่ถ้ามีโจทย์ที่ต้องใช้ All-Pair Shortest Path โค้ด Floyd-Warshall สะดวกมาก แค่ไม่กี่บรรทัดก็เสร็จแล้ว

นอกจากนี้ มี Shortest Path Faster Algorithm (SPFA) ซึ่งเป็นการดัดแปลงผสมผสาน Bellman-Ford กับ BFS เข้าด้วยกัน โค้ดได้ง่าย สามารถหาเส้นทางสั้นสุดได้รวดเร็ว (โดยเฉลี่ย จะหาได้เร็วกว่า Dijkstra's Algorithm) และรองรับกราฟที่มี negative weight ได้ด้วย

หากจำ Dijkstra's Algorithm ไม่ได้ แนะนำให้จำ SPFA ไว้ เผื่อจะช่วยได้ (ถึงอย่างไรก็ตาม ต้องระวังว่า Worst case อาจจะแย่พอ ๆ กับ Bellman-Ford Algorithm)

## Dijkstra’s Algorithm

หลักการทำงานคร่าว ๆ
- ตอนแรกถือว่า distance ไปยังทุก node เป็น infinity ก่อน ยกเว้น node เริ่มต้นเป็น 0 นำใส่คิว
- พิจารณา node ที่ distance น้อยสุดในคิว แล้วปรับ distance ของ node รอบ ๆ (+ edge weight เข้าไป)
- ถ้าปรับได้ ก็ให้นำใส่คิว เพื่อพิจารณาปรับ node รอบ ๆ อีกเรื่อย ๆ จนกว่าจะจบ

ในที่นี้ assume ว่าเก็บกราฟแบบ Adjacency List ที่เป็น `vector<pair<int, int>> G[N]` โดยตัวแรกเก็บหมายเลข node ปลายทาง และตัวที่สองเก็บความยาวของ edge (ตามที่อธิบายด้านบน)

เราต้องการ Priority Queue เพื่อเก็บ node แล้ว sort ตามระยะทาง

วิธีที่ง่ายที่สุดคือ การเก็บ `pair<int, int>` ใน priority_queue โดยที่ตัวแรกเก็บระยะทาง ตัวที่สองเก็บ node เมื่อเก็บอย่างนี้ ตัว `priority_queue` จะ sort ตามตัวแรกก่อน ซึ่งก็คือการ sort ตามระยะทางตามที่เราต้องการนั่นเอง

เนื่องจาก `priority_queue` เป็น max-heap แต่เราต้องการ min-heap ดังนั้น เราต้องใช้ตัว compare เป็น `greater<pii>` แทน (เดิมเป็น `less<pii>`)

```cpp

using pii = pair<int, int>;

vector<int> dist(n+1, INF); // ที่ใช้ n+1 เพราะหมายเลข node ในกราฟอาจจะเป็น 1-based index
vector<bool> visited(n+1, false);

priority_queue<pii, vector<pii>, greater<pii>> Q;
dist[start] = 0;
Q.push({dist[start], start});

while (!Q.empty()) {

    int u = Q.top().second, d = Q.top().first;
    Q.pop();
    if (visited[u])
        continue;
    visited[u] = true;

    if (u == target) { // เจอคำตอบ
        printf("%d\n", dist[target]);
        break;
    }

    for (auto vw : G[u]) { // อย่าลืมว่า adjacency list เรามี (node ปลายทาง, weight)
        int v = vw.first;
        int w = vw.second;
        if (!visited[v] && dist[u]+w < dist[v]) { // ปรับ distance ให้น้อยลง
            dist[v] = dist[u]+w;
            Q.push({dist[v], v}) // ถ้าปรับได้ก็ยัดใส่ queue
        }
    }
}

```

Dijkstra's Algorithm ตามโค้ดนี้จะทำงานใน `O(m + n log n)` ซึ่งถือว่ารวดเร็วพอสมควร แต่ต้องระวัง ห้ามใช้ Dijkstra's Algorithm กับกราฟที่มี negative weight

## Bellman-Ford Algorithm

Bellman-Ford Algorithm มีไว้เพื่อหาเส้นทางสั้นสุด เริ่มต้นจาก node หนึ่งไปยัง node อื่น ๆ ทุก node มีแนวคิดคร่าว ๆ ดังนี้
- นิยามให้ `dist[v]` แทนเส้นทางสั้นสุดจาก node เริ่มต้นไปยัง node `v`
- ตอนแรก ถือว่าทุก node มี `dist[v] = INF` ยกเว้น node เริ่มต้นจะมี `dist[v] = 0`
- พิจารณา edge `(u, v, w)` แต่ละ edge แล้วเปรียบเทียบเส้นทางที่มาถึง node `v` ได้สองเส้นทาง คือ 1) ระยะทางสั้นสุดเดิมที่มาถึง node `v` ได้ (`dist[v]`) และระยะทางสั้นสุดมาถึง node `u` ต่อด้วย edge ดังกล่าวมาถึง node `v` (`dist[u] + w`) นำค่าที่น้อยกว่าเก็บลงใน `dist[v]`
- เมื่อพิจารณาครบทุก edge แล้ว ให้พิจารณาซ้ำอีกรอบ ทำเรื่อย ๆ จนกว่าจะเจอรอบที่ไม่มีการเปลี่ยนแปลงค่า `dist[v]` ใด ๆ แล้วจึงหยุดการทำงานของโปรแกรม

สังเกตว่าวิธีนี้ จะต้องพิจารณา edge ซ้ำทั้งหมดไม่เกิน `n-1` รอบ เพราะ path จาก node เริ่มต้นไปยัง node ใด ๆ ที่เป็นเส้นทางสั้นสุด ย่อมผ่านเส้นไม่เกิน `n-1` เส้น ดังนั้น algorithm นี้จะทำงานในเวลา `O(nm)`

algorithm นี้สามารถใช้หาเส้นทางสั้นสุดได้ในกรณีที่กราฟมี edge ที่มี negative weight (ใช้ Dijkstra's Algorithm ไม่ได้)

ในกรณีที่กราฟมี negative cycle (cycle ที่มี weight รวมติดลบ) algorithm อาจจะไม่จบการทำงาน ดังนั้นให้นับจำนวนรอบที่พิจารณา edge ด้วย หากทำงานรอบที่ `n-1` แล้วยังพบว่ามีการเปลี่ยนแปลงค่า `dist[v]` ก็สามารถสรุปได้ว่ากราฟมี negative cycle

```cpp
// รับกราฟเป็น edge list
struct Edge {
    int u, v, w;
};
vector<Edge> edges;

// bellman-ford:

vector<int> dist(n+1, INF);
dist[start] = 0;

int count = 0;
bool found_changes = false;
bool neg_cycle = false;
do {
    found_changes = false;
    for (auto edge : edges) {
        int u = edge.u, v = edge.v, w = edge.w;
        if (dist[u]+w < dist[v]) {
            dist[v] = dist[u]+w;
            found_change = true;
        }
    }
    ++count;
    if (count > n-1 && found_changes) {
        neg_cycle = true;
        break;
    }
} while (found_changes);
```

## Shortest Path Faster Algorithm (SPFA)

Bellman-Ford Algorithm ทำงานช้าเนื่องจากลำดับ edge ที่พิจารณาทำให้รอบ ๆ หนึ่งมีการปรับค่า `dist[v]` น้อย ยกตัวอย่างกราฟที่ประกอบไปด้วย `n = 5` nodes และ `m = 4` edges ได้แก่ `(1, 2, 1)`, `(2, 3, 1)`, `(3, 4, 1)`, `(4, 5, 1)` (เป็นกราฟเส้นตรงตั้งแต่ node 1 ถึง 5 แต่ละเส้นหนัก 1)

หาเส้นทางสั้นสุดจาก node 0 - เริ่มมา `dist[1] = 0` ส่วน `dist[2..5] = INF` สังเกตว่า ถ้าเราพิจารณา edge `(4, 5, 1)` ก่อน จะไม่มีการเปลี่ยนแปลง `dist[5]` เลย เพราะ `dist[5] >= dist[4]+1` เช่นเดียวกับ edge `(3, 4, 1)` และ `(2, 3, 1)` ทั้งนี้เป็นเพราะ `dist[2..5] = INF` อยู่ ไม่สามารถนำไปใช้ปรับ distance node อื่น ๆ ได้

สังเกตว่า edge เดียวที่ใช้ได้คือ edge `(1, 2, 1)` จะทำให้ `dist[2] = 1` ส่วน `dist[3..5] = INF` เหมือนเดิม หากเราเริ่มใช้ edge นี้ก่อนตั้งแตแรก ตามด้วย edge `(2, 3, 1)`, `(3, 4, 1)` และ `(4, 5 1)` ก็จะทำให้ปรับ distance เสร็จตั้งแต่รอบแรกทันที

ดังนั้น เราจะเลือก edge อย่างชาญฉลาด ดังนี้
- เก็บกราฟเป็น adjacency list แทน
- เก็บ queue ของ node ที่น่าสนใจ เริ่มมาสนใจเฉพาะ node เริ่มต้น
- เมื่อดึง node ออกจากคิว ให้พิจารณาทุก edge ที่ติดกับ node นั้นแล้วปรับ distance ของ node รอบ ๆ
- หากมีการเปลี่ยนแปลง ก็ให้ push node ที่มีการเปลี่ยนแปลงใส่คิว
- ทำไปเรื่อย ๆ จนกว่าจะไม่มีการเปลี่ยนแปลงใด ๆ หรือหากมี node ใดถูกปรับเกิน `n-1` ครั้ง ให้สรุปว่ามี negative cycle

algorithm นี้ โดยเฉลี่ยแล้วจะทำงานใน `O(m)` (ขอไม่กล่าวถึงการพิสูจน์ ณ ที่นี้) แต่มี worst case เป็น `O(nm)` เช่นเดียวกับ Bellman-Ford Algorithm แบบปกติ

สังเกตว่าลักษณะการโค้ดจะโค้ดคล้าย ๆ กับ Breadth-first Search - เพียงแค่ตัด visited array ออกไปเท่านั้น (อนุญาตให้มีการวนกลับมาปรับ node เดิมได้)

```cpp
// adjaceny list
using pii = pair<int, int>;
vector<pii> G[N];

// SPFA:

vector<int> dist(n+1, INF);
vector<int> count(n+1, 0);
dist[start] = 0;
queue<int> Q;
Q.push(start);

bool neg_cycle = false;
while (!Q.empty()) {
    int u = Q.front();
    Q.pop()
    if (++count[u] > n-1) {
        neg_cycle = true;
        break;
    }
    for (auto vw : G[u]) {
        int v = vw.first, w = vw.second;
        if (dist[u] + w < dist[v]) {
            dist[v] = dist[u] + w;
            Q.push(v);
        }
    }
}
```

สังเกตว่า SPFA เป็น algorithm ที่เขียนง่ายมาก โจทย์ส่วนใหญ่ไม่ค่อยได้ generate test case ที่เป็น worst case ของ SPFA ไว้มากนัก ดังนั้น สามารถใช้ algorithm นี้แทน Dijkstra's Algorithm ได้ (ถึงอย่างไรก็ตาม ควรเขียน Dijkstra's Algorithm ดั้งเดิมเป็น)

## Floyd-Warshall Algorithm

นิยามให้ `dist[u][v]` คือเส้นทางสั้นสุดจาก node `u` ไป node `v` ที่รู้ ณ ตอนนั้น
- ตอนแรก เราไม่รู้ระยะทางอะไรเลย ให้ทุกช่องเป็น INF ก่อน
- สำหรับทุก node `u` ให้เซต `dist[u][u] = 0` (เพราะทุก node สามารถเดินทางหาตัวเองได้เป็นระยะทาง 0)
- รับ edge `(u, v, w)` ให้เซต `dist[u][v] = w` (เพราะเรารู้ระยะทางแล้ว)

แล้วเราจะลูปพิจารณา node `k`, `i`, `j` ตามแนวคิดดังนี้
- พิจารณาเส้นทางสั้นสุดจาก `i` ไป `j`, เดิมมีค่าเท่ากับ `dist[i][j]` ตามตาราง
- ถ้าสมมุติ เราเดินทางอ้อมผ่าน node `k` คำตอบจะกลายเป็น `dist[i][k] + dist[k][j]`
- ถามว่า การเดินอ้อมช่วยให้คำตอบดีขึ้นมั้ย ถ้าช่วยให้คำตอบดีขึ้น ให้แก้ `dist[i][j] = dist[i][k]+dist[k][j]`

```cpp
int n, m;
scanf("%d%d", &n, &m);

// เซตค่า 0 กับ INF ตอนแรก
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
        if (i == j)
            dist[i][j] = 0;
        else
            dist[i][j] = INF;
    }
}

// รับ edge ของกราฟมาทั้งหมด
for (int i = 0; i < m; ++i) {
    int u, v, w;
    scanf("%d%d%d", &u, &v, &w);
    dist[u][v] = w;
}

// floyd-warshall
for (int k = 1; k <= n; ++k) {
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j)
            dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);
    }
}
```

สังเกตว่าโค้ดค่อนข้างสั้น อัลกอริทึมนี้ทำงานใน `O(n^3)` ซึ่งสามารถรองรับได้เพียงแค่กราฟขนาดเล็กเท่านั้น สามารถใช้อัลกอริทึมนี้กับกราฟที่มี negative weight ได้ การตรวจสอบ negative cycle ให้ดูค่า `dist[u][u]` ของทุก node `u` - หากมีค่าติดลบ จึงสรุปได้ว่ากราฟมี negative cycle

## ปัญหาประยุกต์ Shortest Path

**Unweighted Graph** 

สำหรับกราฟที่ไม่ได้ระบุน้ำหนักไว้ (ทุกเส้นหนัก 1 เท่ากันหมด) แทนที่จะใช้ Dijkstra's Algorithm เราสามารถใช้ Breadth-first Search ในการหาเส้นทางสั้นสุดได้

**Multiple-Source Shortest Path**

ยกตัวอย่างโจทย์ ดังนี้
> มีตารางขนาด `n*m` ให้ บางช่องอาจมีกำแพง และบางช่องอาจมีเชื้อไวรัสอยู่ ทุก ๆ นาทีเชื้อไวรัสจะแพร่ไปยังช่องบน/ล่าง/ซ้าย/ขวา (แต่จะไม่แพร่ผ่านกำแพง) ให้หาว่าแต่ละช่องจะถูกไวรัสแพร่มานาทีที่เท่าใด (หากมีไวรัสตั้งแต่แรก ให้ถือว่าแพร่มานาทีที่ 0)
>
> เช่น หากตารางขนาด `4*5` มีลักษณะดังนี้ (ช่องที่มี `o` คือมีเชื้อไวรัสอยู่ ส่วน '#' คือกำแพง)
> ```
> - - - # o
> - - - # -
> - # - - -
> o - - - -
> ```
> เชื้อไวรัสจะแพร่กระจายไปยังช่องต่าง ๆ ตามเวลาที่ระบุดังนี้
> ```
> 3 4 5 # 0
> 2 3 4 # 1
> 1 # 3 3 2
> 0 1 2 3 3
> ```

สังเกตว่า แต่ละช่อง ไวรัสที่อยู่ใกล้ที่สุดจะแพร่เข้ามาหา ดังนั้น คำตอบของแต่ละช่องจะเท่ากับ เส้นทางสั้นสุดจากตำแหน่งช่องนั้นไปหาแหล่งไวรัสที่ใกล้ที่สุด วิธีนี้จะใช้เวลานานมาก เพราะเราต้องเริ่มหา shortest path จากทุกจุดเริ่มต้น เนื่องจากมีจุดเริ่มต้นมากสุดถึง `nm` จุด และเราต้อง BFS ทั่วทั้งตารางทั้งหมด `nm` ช่อง รวมแล้ว Time Complexity จะเป็น `O((nm)^2)`

หากเราเปลี่ยนมาพิจารณาแหล่งกำเนิดไวรัสแต่ละแหล่งแทน เราสามารถหาได้ว่า ไวรัสตัวนั้นจะแพร่ไปยังช่องใด ณ เวลาใด ยกตัวอย่างตามกรณีข้างบน ไวรัสตัวมุมบนขวาจะแพร่ในลักษณะนี้
```
8 7 6 # 0
7 6 5 # 1
8 # 4 3 2
7 6 5 4 3
```
ส่วนไวรัสมุมล่างซ้ายจะแพร่ในลักษณะนี้
```
3 4 5 # 7
2 3 4 # 6
1 # 3 4 5
0 1 2 3 4
```
หากเรานำทั้งสองตารางมารวมกัน โดยสนใจเฉพาะค่าที่น้อยที่สุดของแต่ละช่อง ก็จะได้คำตอบตามที่อธิบายไว้ทางด้านบน

วิธีนี้ เราลดจำนวนจุดเริ่มต้นลงเหลือเท่ากับจำนวนแหล่งกำเนิดไวรัส หากมีแหล่งกำเนิดไวรัส `k` จุด จะใช้เวลาทำงานทั้งหมด `O(knm)` ถึงอย่างไรก็ตาม แหล่งกำเนิดไวรัสอาจมีได้มากถึง `O(nm)` จุด ทำให้วิธีนี้ไม่ได้ดีกว่าเดิมมากนัก

วิธีที่ดีที่สุด คือการทำ BFS พร้อมกัน แทนที่จะมีจุดเริ่มต้นเพียงจุดเดียว เราจะเริ่มต้นหลาย ๆ จุด เมื่อทำเช่นนี้ เราจะได้เวลาของตารางแต่ละช่องทันที วิธีนี้ใช้เวลา `O(nm)` ซึ่งดีที่สุดเท่าที่เป็นไปได้แล้ว

**Shortest Path ผ่าน node ที่กำหนด**

> กำหนดกราฟ**ไม่มีทิศทาง**มาให้ ให้หาเส้นทางสั้นสุดจาก node `u` ไป node `v` แต่มีเงื่อนไขพิเศษคือ เส้นทางต้องผ่าน node `x` - ให้ตอบเส้นทางสั้นสุด เมื่อพิจารณา node `x = 1, 2, 3, ..., n`

สังเกตว่า ความยาวทั้งหมดจะเท่ากับ `dist[u][x] + dist[x][v]` เมื่อกำหนดให้ `dist[a][b]` คือเส้นทางสั้นสุดจาก `a` ไป `b`

ถึงอย่างไรก็ตาม เมื่อเราเปลี่ยน node `x` สังเกตว่าเราต้องทำ shortest path เริ่มต้นจาก node `x` ใหม่เสมอ นั่นแปลว่าเราจะต้องทำ shortest path ซ้ำถึง `n` ครั้ง (หรือไม่ก็ต้องทำ Floyd-Warshall ซึ่งช้าพอ ๆ กัน)

สังเกตว่า เราสามารถแก้สมการเป็น `dist[u][x] + dist[v][x]` ได้ เนื่องจากจุดเริ่มต้น `u` และ `v` ไม่มีการเปลี่ยนแปลง นั่นแปลว่าเราต้องทำ shortest path เพียง 2 ครั้งเท่านั้น แล้วลูปทดลองค่า `x` เพื่อหาคำตอบที่น้อยที่สุดได้

อนึ่ง หากเป็นกราฟแบบมีทิศทาง `dist[x][v]` อาจไม่เท่ากับ `dist[v][x]` ทำให้ใช้วิธีดังกล่าวโดยตรงไม่ได้

ถึงอย่างไรก็ตาม `เส้นทางสั้นสุดจาก x ไป v ในกราฟปกติ` จะเท่ากับ `เส้นทางสั้นสุดจาก v ไป x ในกราฟกลับทิศทาง` เราสามารถใช้ประโยชน์จากความจริงนี้ได้ โดยการกลับทิศทาง edge ทุกเส้น แล้วหาเส้นทางสั้นสุดออกจาก node `v` โดยให้กำหนด `เส้นทางสั้นสุดจาก v ไป x ในกราฟกลับทิศทาง` เป็น `dist[x][v]` ของกราฟเดิม เราจะใช้วิธีลูป node `x` เพื่อหาค่า `dist[u][x] + dist[x][v]` ที่น้อยที่สุดได้

**Shortest Path on States**

> กำหนดกราฟให้ ให้หาเส้นทางสั้นสุดจาก `u` ไป `v` โดยมีเงื่อนไขคือเส้นทางจะต้องผ่านจำนวน edge เป็นพหุคูณของ `k` (`k` มีค่าน้อย) เช่น หาก `k=2` เส้นทางจะต้องผ่าน 2, 4, 6, 8, 10, ... edges

สำหรับโจทย์ข้อนี้ เราจำเป็นต้องนิยามกราฟใหม่ขึ้นมา แล้วหา shortest path บนกราฟใหม่ เพราะมีเงื่อนไขจำกัดกว่าเดิม

กำหนดให้กราฟเดิมเป็นกราฟ `G` ส่วนกราฟใหม่เป็นกราฟ `G'`
- สำหรับ node `u` ในกราฟ `G` เราจะถือว่ามี node `(u, 0)`, `(u, 1)`, `(u, 2)`, ..., `(u, k-1)` ในกราฟ `G'`
- สำหรับ edge `(u, v, w)` ในกราฟ `G` เราจะถือว่ามี edge `((u, x), (v, (x+1)%k), w)` สำหรับ `x = 0..k-1` ในกราฟ `G'`

สังเกตว่ากราฟใหม่ที่เราสร้างขึ้นมา จะคล้ายคลึงกับกราฟเก่า แต่จะแบ่งเป็นชั้น ๆ ว่าเราเดินผ่าน edge มาเป็นจำนวนกี่เส้น ทุกครั้งที่เราเดินผ่าน edge ในกราฟเดิม จำนวน edge ที่จดไว้จะเพิ่มขึ้น ถ้าครบ `k` ก็จะวนกลับไปนับ 0 ใหม่

เราต้องหาเส้นทางสั้นสุดจาก node `(u, 0)` ไปยัง node `(v, 0)` ในกราฟนี้ จึงจะได้คำตอบของปัญหาเดิม ซึ่งก็คือ เส้นทางสั้นสุดจาก node `u` ไป node `v` ที่ผ่านจำนวน edge เป็นพหุคูณของ `k` พอดี (สังเกตว่าถ้าเป็นพหุคูณของ `k` จำนวน edge ที่ผ่าน จะต้องวนกลับมาที่ 0 พอดี)

อนึ่ง เนื่องจากเราหาเส้นทางสั้นสุดบนกราฟใหม่ การเก็บตาราง `dist` หรือ `visited` จะต้องใช้เป็น array 2 มิติแทน เช่น node `(u, x)` ต้องเก็บไว้ที่ช่อง `dist[u][x]` เป็นต้น

> กำหนดตารางให้ แต่ละช่องอาจจะเป็นกำแพง ประตู หรือกุญแจ ต้องการเดินจากจุดหนึ่งไปยังอีกจุดหนึ่ง โดยที่เราจะเดินผ่านประตูได้ก็ต่อเมื่อเคยเดินผ่านกุญแจของประตูนั้นแล้ว (คู่ประตู-กุญแจมีไม่กี่คู่)

สำหรับโจทย์ข้อนี้ สังเกตว่า เราสามารถแยกกราฟเป็นชั้น ๆ ได้เช่นกัน แทนที่จะเป็นแค่ตำแหน่ง `(x, y)` ก็อาจจะเก็บไว้ด้วยว่า เคยเก็บกุญแจไหนแล้วบ้าง เช่น หากมีคู่ประตู-กุญแจทั้งหมด 3 คู่ ก็อาจจะเก็บเป็น `(x, y, 0, 1, 1)` ถ้าเคยเก็บกุญแจที่ 2 กับ 3 แล้ว

สังเกตว่าค่าด้านหลัง เราสามารถใช้ตัวเลขปกติเก็บได้ แล้วใช้ bitwise operation ในการตรวจสอบว่าเคยเก็บกุญแจนั้นแล้วหรือยัง หรือใช้ในการกำหนดว่าเคยเก็บกุญแจแล้ว

เราทำ BFS ตามปกติ แต่เมื่อเดินไปในตำแหน่งที่มีกุญแจ แทนที่จะนำ `(x, y, list)` ใส่คิว เราต้องปรับ list กุญแจก่อน แล้วจึงนำใส่คิวได้

เช่นเดียวกับข้อก่อนหน้า ตาราง `dist` และ `visited` ต้องใช้ตาม node ก็คือ `(x, y, list)` ต้องเก็บไว้ใน `dist[x][y][list]`

Credits: [toi14-tutorial](https://github.com/aquablitz11/toi14-tutorial) by aquablitz11